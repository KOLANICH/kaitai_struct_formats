<div class="topic" xmlns="http://www.w3.org/1999/xhtml">
	<h1 class="title">Microsoft Cabinet Format</h1>



	<div id="nstext">&nbsp;

		<h4 class="dtH1">In this Library Section</h4>

		<p><a href="#top">Cabarc User's Guide</a> </p>

		<p><a href="#cabinet_format">Cabinet Format</a> </p>

		<p><a href="#microsoftfcifdilibrarydescription">FCI / FDI</a> </p>

		<p><a href="#lzxdatacompressionformat">LZX Format</a> </p>

		<p><a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> </p>

		<p><a href="#microsoftmszipdatacompressionformat">MSZip Format</a> </p>

		<h2 class="dtH1">
			<a id="top"></a>Microsoft Cabarc User's Guide</h2>

		<p>Copyright © 1997 Microsoft Corporation. All rights reserved.</p>

		<h4 class="dtH1">Topics in this section</h4>

		<p><a href="#intro">Introduction</a>

		</p>
		<ul>
			<li><a href="#cabinet_format_cabarc">The Cabinet Format</a> </li>

			<li><a href="#cabarc">Cabarc</a> </li>

			<li><a href="#com_line_usage">Command Line Usage</a> </li>
		</ul>

		<p><a href="#create_cabs">Creating Cabinets</a>

		</p>
		<ul>
			<li><a href="#wildcards">Wildcards</a> </li>

			<li><a href="#folders">Folders</a> </li>

			<li><a href="#path_pres">Path Name Preservation</a> </li>

			<li><a href="#path_pres">Path Stripping</a> </li>

			<li><a href="#rec_dir_search">Recursive Directory Search</a> </li>

			<li><a href="#res_space_code_sig">Reserve Space for Code Signature</a> </li>

			<li><a href="#set_cab_id">Set Cabinet ID</a> </li>

			<li><a href="#set_comp_type">Set Compression Type</a> </li>

			<li><a href="#list_from_file">File List from a File</a> </li>
		</ul>

		<p><a href="#list_cab_cont">List Cabinet Contents</a> </p>

		<p><a href="#ext_cabs">Extracting Cabinets</a> </p>

		<h2 class="dtH1">
			<a id="intro"></a>Introduction</h2>

		<h3 class="dtH1">
			<a id="cabinet_format_cabarc"></a>The Cabinet Format</h3>

		<p>The cabinet format provides a way to efficiently package multiple files. The key features of the cabinet format are that multiple files may be stored in a single cabinet ("CAB file"); and that data compression is performed across file boundaries, significantly improving the compression ratio.</p>

		<p>Depending upon the number of files to be compressed, and the expected access patterns (sequential or random access; whether most of the files will be requested at once or only a small portion), cabinets can be constructed in different ways. One key concept of the cabinet file is the <em>folder</em>. A <em>folder </em>is a collection of one or more files that are compressed together as a single entity. By compressing files in this way, the compression ratio is improved. The downside is that random access time suffers, since in order for any particular file in a folder to be decoded, all preceding files in the same folder must also be decoded.<br>
			<a href="#top">Back to top</a> </p>

		<h3 class="dtH1">
			<a id="cabarc"></a>Cabarc</h3>

		<p>Cabarc is a utility that creates, extracts, and lists the contents of cabinet files (CABs), using a command line interface similar to that of popular archiving tools. Cabarc supports wildcards and recursive directory searches.</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#intro">Introduction</a> </p>

		<h3 class="dtH1">
			<a id="com_line_usage"></a>Command Line Usage</h3>

		<p>Cabarc is used as follows:</p>

		<pre class="code"><code class="ce">Usage: CABARC [options] command cabfile [@list] [files] [dest_dir]
</code></pre>

		<p>Currently, only three commands are supported; N (create new cabinet), L (list contents of an existing cabinet), and X (extract files from a cabinet). These commands are described in the following pages.</p>

		<p>Options must appear before the command name, and cannot be combined (for example, to set the –r and –p options, use –r –p, and not –rp).</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#intro">Introduction</a> </p>

		<h2 class="dtH1">
			<a id="create_cabs"></a>Creating Cabinets</h2>

		<p>Cabinets are created using the <em>n</em> command, followed by the name of the cabinet to create, followed by a filename list, as shown below:</p>

		<p><code class="ce">cabarc n mycab.cab prog.c prog.h prog.exe readme.txt<br>
</code></p>

		<p>The above command creates the cabinet <em>mycab.cab</em> containing the files "prog.c", "prog.h", "prog.exe", and "readme.txt", in a single folder, using the default compression mode, MSZIP.</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> </p>

		<h3 class="dtH1">
			<a id="wildcards"></a>Wildcards</h3>

		<p>Cabarc supports wildcards in the filename list, as shown in the example below:</p>

		<pre class="code">cabarc n mycab.cab prog.* readme.txt</pre>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#create_cabs">Creating Cabinets</a> </p>

		<h3 class="dtH1">
			<a id="folders"></a>Folders</h3>

		<p>By default, all files are added to a single folder (compression history) in the cabinet. It is possible to tell cabarc to begin a new folder, by inserting the plus (+) symbol as a file to be added, as shown below:</p>

		<pre class="code">cabarc n mycab.cab test.c main.c + test.exe *.obj
</pre>

		<p>The above command creates the cabinet "mycab.cab" with one folder containing "test.c" and "main.c", and a second folder containing "test.exe" and all files matching "*.obj".</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#create_cabs">Creating Cabinets</a> </p>

		<h4 class="dtH1">
			<a id="path_pres"></a>Path Name Preservation</h4>

		<p>By default, directory names are not preserved in the cabinet; only the filename component is stored. For example, the following command will result in the filename "prog.c" being stored in the cabinet:</p>

		<pre class="code">cabarc n mycab.cab c:\source\myproj\prog.c</pre>

		<p>In order to preserve path names, the –p option should be used:</p>

		<pre class="code">cabarc –p n mycab.cab c:\mysource\myproj\prog.c
</pre>

		<p>This command will cause the file to be named "mysource\myproj\prog.c" in the cabinet. Note that the c:\ prefix is still stripped from the filename; cabarc will not allow absolute paths to be stored in the cabinet, nor will it extract such absolute paths.</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#create_cabs">Creating Cabinets</a> </p>

		<h4 class="dtH1">
			<a id="path_strip"></a>Path Stripping</h4>

		<p>In many situations it may be desirable to preserve some of the path name, but not all of it. For example, one might wish to archive everything in the c:\mysource\myproj\ directory, but store only the myproj\ component of the path. This can be accomplished with the path stripping option, -P (capital P).</p>

		<p><code>cabarc –p –P mysource\ n mycab.cab c:\mysource\myproj\prog.c</code></p>

		<p>The –P option strips any strings which begin with the provided string (wildcards are not supported in this case; it is a simple text match). Any absolute path prefixes such as c:\ or \ are stripped before the comparison takes place, so these characters should not be included in the –P option.</p>

		<p>The –P option may be used multiple times to strip out multiple paths; cabarc builds a list of all paths to be stripped, and applies only the first one which matches. For example:</p>

		<p><code>cabarc –p –P mysrc\ –P yoursrc\ n mycab.cab c:\mysrc\myproj\*.* d:\yoursrc\yourproj\*.c</code></p>

		<p>The trailing slash at the end of the path name is important; entering <code>–P mysrc</code> instead of <code>–P mysrc\</code> would cause files to be added as "\myproj\&lt;filename&gt;".</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#create_cabs">Creating Cabinets</a> </p>

		<h4 class="dtH1">
			<a id="rec_dir_search"></a>Recursive Directory Search</h4>

		<p>Cabarc can archive files in a directory and all of its subdirectories, by use of the –r option. For example, the command shown below will archive all files ending in .h that are in c:\msdev\include\, c:\msdev\include\sys, and c:\msdev\include\gl (assuming these directories exist on your system). </p>

		<p><code>cabarc –r –p n mycab.cab c:\msdev\include\*.h</code></p>

		<p>The –p option is used here to preserve the path information when the files are added to the cabinet; without this option, only the filename components would be stored, although sometimes it might be desirable behavior to not use –p.</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#create_cabs">Creating Cabinets</a> </p>

		<h4 class="dtH1">
			<a id="res_space_code_sig"></a>Reserve Space for Code Signature</h4>

		<p>Cabarc can reserve space in the cabinet for a code signature. This is done using the –s option, which reserves a specified amount of empty space in the cabinet. For code signing, 6144 bytes need to be reserved:</p>

		<p><code>cabarc –s 6144 n mycab.cab test.exe</code></p>

		<p>Note that the –s option does not actually write the code signature; it merely reserves space for it in the cabinet. The appropriate code signing utility must be used to fill out the code signature.</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#create_cabs">Creating Cabinets</a> </p>

		<h4 class="dtH1">
			<a id="set_cab_id"></a>Set Cabinet ID</h4>

		<p>Cabinet files have a 16-bit cabinet ID field that is designed for application use. The default value of this field is zero, however, the –i option of cabarc can be used to set this field to any 16-bit value:</p>

		<p><code>cabarc –i 12345 n mycab.cab test.exe</code></p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#create_cabs">Creating Cabinets</a> </p>

		<h4 class="dtH1">
			<a id="set_comp_type"></a>Set Compression Type</h4>

		<p>The default compression type for a cabinet is MSZIP. However, the compression type can be changed with the –m option. Currently only MSZIP compression (-m MSZIP) and no compression (-m NONE) are supported.</p>

		<p>The following command stores files in the cabinet with no compression:</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#create_cabs">Creating Cabinets</a> </p>

		<p><code>cabarc –m NONE n mycab.c *.*</code></p>

		<h4 class="dtH1">
			<a id="list_from_file"></a>File List From a File</h4>

		<p>Cabarc can input its list of files from a text file, instead of from the command line, by using @files ("at files"). This is done by prefixing with the @ symbol the name of the file which contains the file list. For example:</p>

		<p><code>cabarc n mycab.cab @filelist.txt</code></p>

		<p>The text file must list the physical file names of the files to be added, one per line. As is the case when specifying filenames on the command line, the plus (+) symbol can be used as a filename to specify the beginning of a new folder. If a filename contains any embedded spaces, it must be enclosed as quotes, as shown below:</p>

		<p><code>test.c</code></p>

		<p><code>myapp.exe</code></p>

		<p><code>"output file.exe"</code></p>

		<p>The reason for requiring quotes is that each physical filename may be followed on the same line by an optional logical filename, which specifies the name under which the file will be stored in the cabinet:</p>

		<p><code>test.c myapp.c</code></p>

		<p><code>myapp.exe</code></p>

		<p><code>"output file.exe" foobar.exe</code></p>

		<p>If the logical filename contains spaces, then it must also be enclosed in quotes. Note that the logical filename overrides the –p (preserve path names) and –P (strip path name) options -the file will be added to the cabinet <em>exactly</em> as indicated. Wildcards are allowed in the physical filename, but in this situation a logical filename is not allowed.</p>

		<p>The "@" feature may be used multiple times, to retrieve file lists from multiple files. Cabarc does not check for the presence of duplicate files, so if the same physical file appears in multiple file lists, it will be added to the cabinet multiple times. </p>

		<p>The "@" feature may be combined with filenames on the command line. Files are added in the order in which they are parsed on the command line. Example:</p>

		<p><code>cabarc n mycab.cab @filelist1.txt *.c @filelist2.txt *.h</code></p>

		<p>Note: The "@" feature is available only when creating cabinets, not when extracting or listing cabinets.</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> &gt; <a href="#create_cabs">Creating Cabinets</a> </p>

		<h3 class="dtH1">
			<a id="list_cab_cont"></a>List Cabinet Contents</h3>

		<p>It is possible to view the contents of a cabinet using the L (list) command, as shown below:</p>

		<p><code>cabarc l mycab.cab</code></p>

		<p>Cabarc will display the Set ID in the cabinet (see the –s option for cabinet creation), as well as the name of each file in the cabinet, along with its file size, file date, file time, and file attributes.</p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> </p>

		<h3 class="dtH1">
			<a id="ext_cabs"></a>Extracting Cabinets</h3>

		<p>The X (extract) command extracts files from a cabinet. The simplest use of the X command is shown below, which causes all files to be extracted from the cabinet:</p>

		<p><code>cabarc x mycab.cab</code></p>

		<p>Alternatively, it is possible to selectively extract files, by providing a list of filenames and/or wildcards:</p>

		<p><code>cabarc x mycab.cab readme.txt *.exe *.c</code></p>

		<p>By default, full path names (if they are present in the cabinet) are <em>not</em> preserved upon extraction. For example, if a file named <em>mysrc\myproj\test.c</em> is present in the cabinet, then the command <code>cabarc x mycab.cab </code>will cause the file <em>test.c</em> to be extracted into the current directory. In order to preserve file names upon extraction, the –p option must be used. This option will cause any required directories to be created if necessary.</p>

		<p>Only the filename component is considered in the matching process; the pathname is discounted. For example, <code>cabarc x mycab.cab test.c</code> will cause the file <em>mysrc\myproj\test.c</em> to be extracted to the current directory as <em>test.c</em>, as will <code>cabarc x mycab.cab *.c</code> (which will also extract any other files matching *.c).</p>

		<p>By default, the extracted files are stored in the current directory (and its subdirectories, if –p is used). However, it is possible to specify a destination directory for the extracted files. This is accomplished by appending a directory name to the command line. The directory name must end in a backslash ( \ ). Examples:</p>

		<p><code>cabarc x mycab.cab c:\somedir\</code></p>

		<p><code>cabarc x mycab.cab *.exe c:\somedir\</code></p>

		<p>Back to: <a href="#top">Cabarc User's Guide</a> </p>

		<h2 class="dtH1">
			<a id="cabinet_format"></a>Microsoft Cabinet File Format</h2>

		<p>Copyright © 1997 Microsoft Corporation. All rights reserved.</p>

		<h4 class="dtH1">Topics in this section</h4>

		<p><a href="#cabfileformatintro">Introduction</a> </p>

		<p><a href="#cabfileformatspec">Specification</a>

		</p>
		<ul>
			<li><a href="#cabfileformatconventions">Conventions</a> </li>

			<li><a href="#cabfileformatoverview">Overview</a> </li>

			<li><a href="#struct_spec">Detailed Structure Specification</a>
				<ul>
					<li><a href="#cfheader">CFHEADER</a> </li>

					<li><a href="#cffolder">CFFOLDER</a> </li>

					<li><a href="#cffile">CFFILE</a> </li>
				</ul>
			</li>
		</ul>

		<p><a href="#sample_cab">Sample Cabinet File</a> </p>

		<p><a href="#notes">Notes</a>

		</p>
		<ul>
			<li><a href="#chksum">Checksum Method</a> </li>

			<li><a href="#utf_enc">UTF Encoding Method</a> </li>
		</ul>

		<h3 class="dtH1">
			<a id="cabfileformatintro"></a>Introduction</h3>

		<p>This specification defines the Microsoft cabinet file format. Cabinet files are compressed packages containing a number of related files. The format of a cabinet file is optimized for maximum compression. Cabinet files support a number of compression formats, including MSZIP, LZX, or uncompressed. This document does not define these internal compression formats. For data compression formats, refer to the documents titled <em>Microsoft MSZIP Data Compression Format</em> and <em>Microsoft LZX Data Compression Format</em>.</p>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> </p>

		<h3 class="dtH1">
			<a id="cabfileformatspec"></a>Specification</h3>

		<p>This segment of the documentation includes the following topics:</p>

		<p><a href="#cabfileformatconventions">Conventions</a> </p>

		<p><a href="#cabfileformatoverview">Overview</a> </p>

		<p><a href="#struct_spec">Detailed Structure Specification</a>

		</p>
		<ul>
			<li><a href="#cfheader">CFHEADER</a> </li>

			<li><a href="#cffolder">CFFOLDER</a> </li>

			<li><a href="#cffile">CFFILE</a> </li>
		</ul>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> </p>

		<h4 class="dtH1">
			<a id="cabfileformatconventions"></a>Conventions </h4>

		<p>The types <code>u1</code>, <code>u2</code>, and <code>u4</code> are used to represent unsigned 8-, 16-, and 32-bit integer values, respectively. All multi-byte quantities are stored in little-endian order, where the least significant byte comes first. </p>

		<p>The cabinet file format is described here using a C-like structure notation, where successive fields appear in the structure sequentially without padding or alignment. Header fields followed by (optional) may or may not be present, depending on the values in the <code>CFHEADER</code> flags byte.</p>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> </p>

		<h4 class="dtH1">
			<a id="cabfileformatoverview"></a>Overview</h4>

		<p>Each file stored in a cabinet is stored completely within a single folder. A cabinet file may contain one or more folders, or portions of a folder. A folder can span across multiple cabinets. Such a series of cabinet files form a set. Each cabinet file contains name information for the logically adjacent cabinet files. Each folder contains one or more files. Throughout this discussion, cabinets are said to contain "files". This is for semantic purposes only. Cabinet files actually store streams of bytes, each with a name and some other common attributes. Whether these byte streams are actually files or some other kind of data is application-defined.</p>

		<p>A cabinet file contains a cabinet header (<code>CFHEADER</code>), followed by one or more cabinet folder (<code>CFFOLDER</code>) entries, a series of one or more cabinet file (<code>CFFILE</code>) entries, and the actual compressed file data in <code>CFDATA</code> entries. The compressed file data in the <code>CFDATA</code> entry is stored in one of several compression formats, as indicated in the corresponding <code>CFFOLDER</code> structure. The compression encoding formats used are detailed in separate documents.</p>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> </p>

		<h4 class="dtH1">
			<a id="struct_spec"></a>Detailed Structure Specification</h4>

		<p>This segment of the documentation includes the following topics:</p>

		<p><a href="#cfheader">CFHEADER</a> </p>

		<p><a href="#cffolder">CFFOLDER</a> </p>

		<p><a href="#cffile">CFFILE</a> </p>

		<p><a href="#cfdata">CFDATA</a> </p>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> </p>

		<h4 class="dtH1">
			<a id="cfheader"></a>CFHEADER</h4>

		<p>The <code class="ce">CFHEADER</code> structure provides information about this cabinet file.</p>

		<pre class="code">struct CFHEADER
{
  u1  <a href="#cfheader_sig">signature[4]</a>inet file signature */
  u4  <a href="#cfheader_res1">reserved1</a>     /* reserved */
  u4  <a href="#cfheader_cbcab">cbCabinet</a>    /* size of this cabinet file in bytes */
  u4  <a href="#cfheader_res2">reserved2</a>     /* reserved */
  u4  <a href="#cfheader_cofffiles">coffFiles</a>/* offset of the first CFFILE entry */
  u4  <a href="#cfheader_res3">reserved3</a>     /* reserved */
  u1  <a href="#cfheader_ver">versionMinor</a>   /* cabinet file format version, minor */
  u1  <a href="#cfheader_ver">versionMajor</a>   /* cabinet file format version, major */
  u2  <a href="#cfheader_cfolders">cFolders</a>  /* number of CFFOLDER entries in this */
						/*    cabinet */
  u2  <a href="#cfheader_cfiles">cFiles</a>      /* number of CFFILE entries in this cabinet */
  u2  <a href="#cfheader_flags">flags</a>        /* cabinet file option indicators */
  u2  <a href="#cfheader_setid">setID</a>        /* must be the same for all cabinets in a */
						/*    set */
  u2  <a href="#cfheader_icab">iCabinet</a>;         /* number of this cabinet file in a set */
  u2  <a href="#cfheader_cbcfhead">cbCFHeader</a>;       /* (optional) size of per-cabinet reserved */
						/*    area */
  u1  <a href="#cfheader_cbcffold">cbCFFolder</a>;       /* (optional) size of per-folder reserved */
						/*    area */
  u1  <a href="#cfheader_cbcfdata">cbCFData</a>;         /* (optional) size of per-datablock reserved */
						/*    area */
  u1  <a href="#cfheader_abres">abReserve[]</a>;      /* (optional) per-cabinet reserved area */
  u1  <a href="#cfheader_szcabprev">szCabinetPrev[]</a>;  /* (optional) name of previous cabinet file */
  u1  <a href="#cfheader_szdiskprev">szDiskPrev[]</a>;     /* (optional) name of previous disk */
  u1  <a href="#cfheader_szcabnext">szCabinetNext[]</a>;  /* (optional) name of next cabinet file */
  u1  <a href="#cfheader_szdisknext">szDiskNext[]</a>;     /* (optional) name of next disk */
};
</pre>

		<dl>
			<dt><strong><a id="cfheader_sig"></a>u1 signature[4]</strong></dt>

			<dd>Contains the characters 'M','S','C','F' (bytes 0x4D, 0x53, 0x43, 0x46). This field is used to assure that the file is a cabinet file.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_res1"></a>u4 reserved1</strong></dt>

			<dd>Reserved field, set to zero.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_cbcab"></a>u4 cbCabinet</strong></dt>

			<dd>Total size of this cabinet file in bytes.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_res2"></a>u4 reserved2</strong></dt>

			<dd>Reserved field, set to zero.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_cofffiles"></a>u4 coffFiles</strong></dt>

			<dd>Absolute file offset of first <code class="ce">CFFILE</code> entry.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_res3"></a>u4 reserved3</strong></dt>

			<dd>Reserved field, set to zero.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_ver"></a>u1 versionMinor</strong></dt>

			<dt><strong>u1 versionMajor</strong></dt>

			<dd>Cabinet file format version.<br> Currently, <code class="ce">versionMajor</code>&nbsp;=&nbsp;1 and <code class="ce">versionMinor</code>&nbsp;=&nbsp;3.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_cfolders"></a>u2 cFolders</strong></dt>

			<dd>The number of <code class="ce">CFFOLDER</code> entries in this cabinet file.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_cfiles"></a>u2 cFiles</strong></dt>

			<dd>The number of <code class="ce">CFFILE</code> entries in this cabinet file.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_flags"></a>u2 flags</strong></dt>

			<dd>Bit-mapped values that indicate the presence of optional data: </dd>
		</dl>

		<pre class="code">#define cfhdrPREV_CABINET       0x0001
#define cfhdrNEXT_CABINET       0x0002
#define cfhdrRESERVE_PRESENT    0x0004
</pre>

		<p><code class="ce">flags.cfhdrPREV_CABINET</code> is set if this cabinet file is not the first in a set of cabinet files. When this bit is set, the <code class="ce">szCabinetPrev</code> and <code class="ce">szDiskPrev</code> fields are present in this <code class="ce">CFHEADER</code>.</p>

		<p><code class="ce">flags.cfhdrNEXT_CABINET</code> is set if this cabinet file is not the last in a set of cabinet files. When this bit is set, the <code class="ce">szCabinetNext</code> and <code class="ce">szDiskNext</code> fields are present in this <code class="ce">CFHEADER</code>.</p>

		<p><code class="ce">flags.cfhdrRESERVE_PRESENT</code> is set if this cabinet file contains any reserved fields. When this bit is set, the <code class="ce">cbCFHeader</code>, <code class="ce">cbCFFolder</code>, and <code class="ce">cbCFData</code> fields are present in this <code class="ce">CFHEADER</code>.</p>

		<p>Other bit positions in the <code class="ce">flags</code> field are reserved. </p>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>

		</p>
		<dl>
			<dt><strong><a id="cfheader_setid"></a>u2 setID</strong></dt>

			<dd>An arbitrarily derived (random) value that binds a collection of linked cabinet files together. All cabinet files in a set will contain the same <code class="ce">setID</code>. This field is used by cabinet file extractors to assure that cabinet files are not inadvertently mixed. This value has no meaning in a cabinet file that is not in a set.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_icab"></a>u2 iCabinet</strong></dt>

			<dd>Sequential number of this cabinet in a multi-cabinet set. The first cabinet has <code class="ce">iCabinet</code>=0. This field, along with <code class="ce">setID</code>, is used by cabinet file extractors to assure that this cabinet is the correct continuation cabinet when spanning cabinet files.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_cbcfhead"></a>u2 cbCFHeader(optional)</strong></dt>

			<dd>If <code class="ce">flags.cfhdrRESERVE_PRESENT</code> is not set, this field is not present, and the value of <code class="ce">cbCFHeader</code> defaults to zero. Indicates the size in bytes of the <code class="ce">abReserve</code> field in this <code class="ce">CFHEADER</code>. Values for <code class="ce">cbCFHeader</code> range from 0 to 60,000.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_cbcffold"></a>u1 cbCFFolder(optional)</strong></dt>

			<dd>If <code class="ce">flags.cfhdrRESERVE_PRESENT</code> is not set, then this field is not present, and the value of <code class="ce">cbCFFolder</code> defaults to zero. Indicates the size in bytes of the <code class="ce">abReserve</code> field in each <code class="ce">CFFOLDER</code> entry. Values for <code class="ce">cbCFFolder</code> range from 0 to 255.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_cbcfdata"></a>u1 cbCFData(optional)</strong></dt>

			<dd>If <code class="ce">flags.cfhdrRESERVE_PRESENT</code> is set, then this field is not present, and the value for <code class="ce">cbCFData</code> defaults to zero. Indicates the size in bytes of the <code class="ce">abReserve</code> field in each <code class="ce">CFDATA</code> entry. Values for <code class="ce">cbCFData</code> range from 0 to 255.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_abres"></a>u1 abReserve[cbCFHeader](optional)</strong></dt>

			<dd>If <code class="ce">flags.cfhdrRESERVE_PRESENT</code> is set and <code class="ce">cbCFHeader</code> is non-zero, then this field contains per-cabinet-file application information. This field is defined by the application and used for application-defined purposes.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_szcabprev"></a>u1 szCabinetPrev[](optional)</strong></dt>

			<dd>If <code class="ce">flags.cfhdrPREV_CABINET</code> is not set, then this field is not present. NUL-terminated ASCII string containing the file name of the logically previous cabinet file. May contain up to 255 bytes plus the NUL byte. Note that this gives the name of the most-recently-preceding cabinet file that contains the initial instance of a file entry. This might not be the immediately previous cabinet file, when the most recent file spans multiple cabinet files. If searching in reverse for a specific file entry, or trying to extract a file that is reported to begin in the "previous cabinet", <code class="ce">szCabinetPrev</code> would give the name of the cabinet to examine.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_szdiskprev"></a>u1 szDiskPrev[](optional)</strong></dt>

			<dd>If <code class="ce">flags.cfhdrPREV_CABINET</code> is not set, then this field is not present. NUL-terminated ASCII string containing a descriptive name for the media containing the file named in <code class="ce">szCabinetPrev</code>, such as the text on the diskette label. This string can be used when prompting the user to insert a diskette. May contain up to 255 bytes plus the NUL byte.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_szcabnext"></a>u1 szCabinetNext[](optional)</strong></dt>

			<dd>If <code class="ce">flags.cfhdrNEXT_CABINET</code> is not set, then this field is not present. NUL-terminated ASCII string containing the file name of the next cabinet file in a set. May contain up to 255 bytes plus the NUL byte. Files extending beyond the end of the current cabinet file are continued in the named cabinet file.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>

			<dt><strong><a id="cfheader_szdisknext"></a>u1 szDiskNext[](optional)</strong></dt>

			<dd>If <code class="ce">flags.cfhdrNEXT_CABINET</code> is not set, then this field is not present. NUL-terminated ASCII string containing a descriptive name for the media containing the file named in <code class="ce">szCabinetNext</code>, such as the text on the diskette label. May contain up to 255 bytes plus the NUL byte. This string can be used when prompting the user to insert a diskette.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfheader">CFHEADER</a>
				</p>
			</dd>
		</dl>

		<h4 class="dtH1">
			<a id="cffolder"></a>CFFOLDER</h4>

		<p>Each <code class="ce">CFFOLDER</code> structure contains information about one of the folders or partial folders stored in this cabinet file. The first <code class="ce">CFFOLDER</code> entry immediately follows the <code class="ce">CFHEADER</code> entry and subsequent <code class="ce">CFFOLDER</code> records for this cabinet are contiguous. <code class="ce">CFHEADER.cFolders</code> indicates how many <code class="ce">CFFOLDER</code> entries are present.</p>

		<p>Folders may start in one cabinet, and continue on to one or more succeeding cabinets. When the cabinet file creator detects that a folder has been continued into another cabinet, it will complete that folder as soon as the current file has been completely compressed. Any additional files will be placed in the next folder. Generally, this means that a folder would span at most two cabinets, but if the file is large enough, it could span more than two cabinets.</p>

		<p><code class="ce">CFFOLDER</code> entries actually refer to folder fragments, not necessarily complete folders. A <code class="ce">CFFOLDER</code> structure is the beginning of a folder if the <code class="ce">iFolder</code> value in the first file referencing the folder does not indicate the folder is continued from the previous cabinet file.</p>

		<p>The <code class="ce">typeCompress</code> field may vary from one folder to the next, unless the folder is continued from a previous cabinet file.</p>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> </p>

		<pre class="code">struct CFFOLDER
{
  u4  <a href="#cffolder_coffcabstart">coffCabStart</a>;  /* offset of the first CFDATA block in this 
					 /*    folder */
  u2  <a href="#cffolder_ccfdata">cCFData</a>;       /* number of CFDATA blocks in this folder */
  u2  <a href="#cffolder_typecomp">typeCompress</a>;  /* compression type indicator */
  u1  <a href="#cffolder_abres">abReserve[]</a>;   /* (optional) per-folder reserved area */
};
</pre>

		<dl>
			<dt><strong><a id="cffolder_coffcabstart"></a>u4 coffCabStart</strong></dt>

			<dd>Absolute file offset of first <code class="ce">CFDATA</code> block for this folder. For a standard cabinet file this value should be less than <code class="ce">CFHEADER.cbCabinet</code>.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffolder">CFFOLDER</a>
				</p>
			</dd>

			<dt><strong><a id="cffolder_ccfdata"></a>u2 cCFData</strong></dt>

			<dd>Number of CFDATA structures for this folder that are actually in this cabinet. A folder can continue into another cabinet and have more CFDATA blocks in that cabinet, and a folder may have started in a previous cabinet. This number represents only the CFDATA structures for this folder that are at least partially recorded in this cabinet.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffolder">CFFOLDER</a>
				</p>
			</dd>

			<dt><strong><a id="cffolder_typecomp"></a>u2 typeCompress</strong></dt>

			<dd>Indicates the compression method used for all <code class="ce">CFDATA</code> entries in this folder. The valid values are defined in each compression format's specification.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffolder">CFFOLDER</a>
				</p>
			</dd>

			<dt><strong><a id="cffolder_abres"></a>u1 abReserve[CFHEADER.cbCFFolder](optional)</strong></dt>

			<dd>If <code class="ce">CFHEADER.flags.cfhdrRESERVE_PRESENT</code> is set and <code class="ce">cbCFFolder</code> is non-zero, then this field contains per-folder application information. This field is defined by the application and used for application-defined purposes.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffolder">CFFOLDER</a>
				</p>
			</dd>
		</dl>

		<h4 class="dtH1">
			<a id="cffile"></a>CFFILE</h4>

		<p>Each <code class="ce">CFFILE</code> entry contains information about one of the files stored (or at least partially stored) in this cabinet. The first <code class="ce">CFFILE</code> entry in each cabinet is found at absolute offset <code class="ce">CFHEADER.coffFiles</code>. In a standard cabinet file the first <code class="ce">CFFILE</code> entry immediately follows the last <code class="ce">CFFOLDER</code> entry. Subsequent <code>CFFILE</code> records for this cabinet are contiguous.</p> <code class="ce">CFHEADER.cFiles</code> indicates how many of these entries are in the cabinet. The <code class="ce">CFFILE</code> entries in a standard cabinet are ordered by <code class="ce">iFolder</code> value, then by <code class="ce">uoffFolderStart</code>. Entries for files continued from the previous cabinet will be first, and entries for files continued to the next cabinet will be last.

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> </p>

		<pre class="code">struct CFFILE
{
  u4  <a href="#cffile_cbfile">cbFile</a>;           /* uncompressed size of this file in bytes */
  u4  <a href="#cffile_uofffoldstart">uoffFolderStart</a>;  /* uncompressed offset of this file in the folder */
  u2  <a href="#cffile_ifold">iFolder</a>;          /* index into the CFFOLDER area */
  u2  <a href="#cffile_date">date</a>;             /* date stamp for this file */
  u2  <a href="#cffile_time">time</a>;             /* time stamp for this file */
  u2  <a href="#cffile_attribs">attribs</a>;          /* attribute flags for this file */
  u1  <a href="#cffile_szname">szName[]</a>;         /* name of this file */
};
</pre>

		<dl>
			<dt><strong><a id="cffile_cbfile"></a>u4 cbFile</strong></dt>

			<dd>Uncompressed size of this file in bytes.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffile">CFFILE</a>
				</p>
			</dd>

			<dt><strong><a id="cffile_uofffoldstart"></a>u4 uoffFolderStart</strong></dt>

			<dd>Uncompressed byte offset of the start of this file's data. For the first file in each folder, this value will usually be zero. Subsequent files in the folder will have offsets that are typically the running sum of the <code class="ce">cbFile</code> values.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffile">CFFILE</a>
				</p>
			</dd>

			<dt><strong><a id="cffile_ifold"></a>u2 iFolder</strong></dt>

			<dd>Index of the folder containing this file's data. A value of zero indicates this is the first folder in this cabinet file. The special <code class="ce">iFolder</code> values <code class="ce">ifoldCONTINUED_FROM_PREV</code> and <code class="ce">ifoldCONTINUED_PREV_AND_NEXT</code> indicate that the folder index is actually zero, but that extraction of this file would have to begin with the cabinet named in <code class="ce">CFHEADER.szCabinetPrev</code>. The special <code class="ce">iFolder</code> values <code class="ce">ifoldCONTINUED_PREV_AND_NEXT</code> and <code class="ce">ifoldCONTINUED_TO_NEXT</code> indicate that the folder index is actually one less than <code class="ce">CFHEADER.cFolders</code>, and that extraction of this file will require continuation to the cabinet named in <code class="ce">CFHEADER.szCabinetNext</code>.</dd>
		</dl>

		<pre class="code">#define ifoldCONTINUED_FROM_PREV      (0xFFFD)
#define ifoldCONTINUED_TO_NEXT        (0xFFFE)
#define ifoldCONTINUED_PREV_AND_NEXT  (0xFFFF)</pre>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffile">CFFILE</a>

		</p>
		<dl>
			<dt><strong><a id="cffile_date"></a>u2 date</strong></dt>

			<dd>Date of this file, in the format <code class="ce">((year–1980) &lt;&lt; 9)+(month &lt;&lt; 5)+(day)</code>, where <code class="ce">month</code>={1..12} and <code class="ce">day</code>={1..31}. This "date" is typically considered the "last modified" date in local time, but the actual definition is application-defined.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffile">CFFILE</a>
				</p>
			</dd>

			<dt><strong><a id="cffile_time"></a>u2 time</strong></dt>

			<dd>Time of this file, in the format <code class="ce">(hour &lt;&lt; 11)+(minute &lt;&lt; 5)+(seconds/2)</code>, where <code class="ce">hour</code>={0..23}. This "time" is typically considered the "last modified" time in local time, but the actual definition is application-defined.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffile">CFFILE</a>
				</p>
			</dd>

			<dt><strong><a id="cffile_attribs"></a>u2 attribs</strong></dt>

			<dd>Attributes of this file; may be used in any combination:</dd>
		</dl>

		<pre class="code">#define  _A_RDONLY       (0x01)  /* file is read-only */
#define  _A_HIDDEN       (0x02)  /* file is hidden */
#define  _A_SYSTEM       (0x04)  /* file is a system file */
#define  _A_ARCH         (0x20)  /* file modified since last backup */
#define  _A_EXEC         (0x40)  /* run after extraction */
#define  _A_NAME_IS_UTF  (0x80)  /* szName[] contains UTF */</pre>

		<p>All other attribute bit values are reserved. </p>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffile">CFFILE</a>

		</p>
		<dl>
			<dt><strong><a id="cffile_szname"></a>char szName[]</strong></dt>

			<dd>NUL-terminated name of this file. Note that this string may include path separator characters. When <code class="ce">attribs._A_NAME_IS_UTF</code> is set, this string can be converted directly to Unicode, avoiding locale-specific dependencies. See "<a href="#utf_enc">UTF Encoding Method</a>" for more information. When <code class="ce">attribs._A_NAME_IS_UTF</code> is not set, this string is subject to interpretation depending on locale.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cffile">CFFILE</a>
				</p>
			</dd>
		</dl>

		<h4 class="dtH1">
			<a id="cfdata"></a>CFDATA </h4>

		<p>Each <code>CFDATA</code> record describes some amount of compressed data. The first <code>CFDATA</code> entry for each folder is located using <code>CFFOLDER.coffCabStart</code>. Subsequent <code>CFDATA</code> records for this folder are contiguous. In a standard cabinet all the <code>CFDATA</code> entries are contiguous and in the same order as the <code>CFFOLDER</code> entries that refer them.</p>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> </p>

		<pre class="code">struct CFDATA
{
  u4  <a href="#cfdata_csum">csum</a>;         /* checksum of this CFDATA entry */
  u2  <a href="#cfdata_cbdata">cbData</a>;       /* number of compressed bytes in this block */
  u2  <a href="#cfdata_cbuncomp">cbUncomp</a>;     /* number of uncompressed bytes in this block */
  u1  <a href="#cfdata_abres">abReserve[]</a>;  /* (optional) per-datablock reserved area */
  u1  <a href="#cfdata_ab">ab[cbData]</a>;   /* compressed data bytes */
};
</pre>

		<dl>
			<dt><strong><a id="cfdata_csum"></a>u4 csum</strong></dt>

			<dd>Checksum of this <code>CFDATA</code> structure, from <code>CFDATA.cbData</code> through <code>CFDATA.ab[cbData</code>-1<code>]</code>. See "<a href="#chksum">Checksum Method</a>" for more information. May be set to zero if the checksum is not supplied.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfdata">CFDATA</a>
				</p>
			</dd>

			<dt><strong><a id="cfdata_cbdata"></a>u2 cbData</strong></dt>

			<dd>Number of bytes of compressed data in this CFDATA record. When cbUncomp is zero, this field indicates only the number of bytes that fit into this cabinet file.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfdata">CFDATA</a>
				</p>
			</dd>

			<dt><strong><a id="cfdata_cbuncomp"></a>u2 cbUncomp</strong></dt>

			<dd>The uncompressed size of the data in this CFDATA entry. When this CFDATA entry is continued in the next cabinet file, cbUncomp will be zero, and cbUncomp in the first CFDATA entry in the next cabinet file will report the total uncompressed size of the data from both CFDATA blocks.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfdata">CFDATA</a>
				</p>
			</dd>

			<dt><strong><a id="cfdata_abres"></a>u1 abReserve[CFHEADER.cbCFData](optional)</strong></dt>

			<dd>If CFHEADER.flags.cfhdrRESERVE_PRESENT is set and cbCFHeader is non-zero, then this field contains per-datablock application information. This field is defined by the application and used for application-defined purposes.

				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfdata">CFDATA</a>
				</p>
			</dd>

			<dt><strong><a id="cfdata_ab"></a>u1 ab[cbData]</strong></dt>

			<dd>The compressed data bytes, compressed using the CFFOLDER.typeCompress method. When cbUncomp is zero, these data bytes must be combined with the data bytes from the next cabinet's first CFDATA entry before decompression.

				<p>When <code>CFFOLDER.typeCompress</code> indicates that the data is not compressed, this field contains the uncompressed data bytes. In this case, <code>cbData</code> and <code>cbUncomp</code> will be equal unless this CFDATA entry crosses a cabinet file boundary.


				</p>
				<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> &gt; <a href="#cabfileformatspec">Specification</a> &gt; <a href="#cfdata">CFDATA</a>
				</p>
			</dd>
		</dl>

		<h3 class="dtH1">
			<a id="sample_cab"></a>A Sample Cabinet File</h3>

		<pre class="code">       0   1   2   3   4   5   6    7    8   9   A   B   C   D   E   F
000   4D   53  43  46  00  00  00 00-FD  00  00  00  00  00  00  00  MSCF
010   2C   00  00  00  00  00  00 00-03  01  01  00  02  00  00  00  
020   22   06  00  00  5E  00  00 00-01  00  00  00  4D  00  00  00  
030   00   00  00  00  00  00  6C 22-BA  59  20  00  68  65  6C  6C  hell
040   6F   2E  63  00  4A  00  00 00-4D  00  00  00  00  00  6C  22  o.c
050   E7   59  20  00  77  65  6C 63-6F  6D  65  2E  63  00  BD  5A  welcome.c
060   A6   30  97  00  97  00  23 69-6E  63  6C  75  64  65  20  3C  #include &lt;
070   73   74  64  69  6F  2E  68 3E-0D  0A  0D  0A  76  6F  69  64  stdio.h&gt;    void
080   20   6D  61  69  6E  28  76 6F-69  64  29  0D  0A  7B  0D  0A  main(void)  {
090   20   20  20  20  70  72  69 6E-74  66  28  22  48  65  6C  6C  printf("Hell
0A0   6F   2C  20  77  6F  72  6C 64-21  5C  6E  22  29  3B  0D  0A  o, world!\n");
0B0   7D   0D  0A  23  69  6E  63 6C-75  64  65  20  3C  73  74  64  }  #include &lt;std
0C0   69   6F  2E  68  3E  0D  0A 0D-0A  76  6F  69  64  20  6D  61  io.h&gt;    void ma
0D0   69   6E  28  76  6F  69  64 29-0D  0A  7B  0D  0A  20  20  20  in(void)  {
0E0   20   70  72  69  6E  74  66 28-22  57  65  6C  63  6F  6D  65  printf("Welcome
0F0   21   5C  6E  22  29  3B  0D 0A-7D  0D  0A  0D  0A              !\n");  }
</pre>

		<p>This is a very simple example of a cabinet file which contains two small text files, stored uncompressed for clarity.</p>

		<p>Back to: <a href="#cabinet_format">Cabinet File Format</a> </p>

		<pre class="code">   Offset   Description
   00..23   CFHEADER
   00..03   signature = 0x4D, 0x53, 0x43, 0x46
   04..07   reserved1
   08..0B   cbCabinet = 0x000000FD (253)
   0C..0F   reserved2
   10..13   coffFiles = 0x0000002C
   14..17   reserved3
   18..19   versionMinor, Major = 1.3
   1A..1B   cFolders = 1
   1C..1D   cFiles = 2
   1E..1F   flags = 0 (no reserve, no previous or next cabinet)
   20..21   setID = 0x0622
   22..23   iCabinet = 0

   24..2B   CFFOLDER[0]
   24..27   coffCabStart = 0x0000005E
   28..29   cCFData = 1
   2A..2B   typeCompress = 0 (none)

   2C..43   CFFILE[0]
   2C..2F   cbFile = 0x0000004D (77 bytes)
   30..33   uoffFolderStart = 0x00000000
   34..35   iFolder = 0
   36..37   date = 0x226C = 0010001 0011 01100 = March 12, 1997
   38..39   time = 0x59BA = 01011 001101 11010 = 11:13:52 AM
   3A..3B   attribs = 0x0020 = _A_ARCHIVE
   3C..43   szName = "hello.c" + NUL

   44..5D   CFFILE[1]
   44..47   cbFile = 0x0000004A (74 bytes)
   48..4B   uoffFolderStart = 0x0000004D
   4C..4D   iFolder = 0
   4E..4F   date = 0x226C = 0010001 0011 01100 = March 12, 1997
   50..51   time = 0x59E7 = 01011 001111 00111 = 11:15:14 AM
   52..53   attribs = 0x0020 = _A_ARCHIVE
   54..5D   szName = "welcome.c" + NUL

   5E..FD   CFDATA[0]
   5E..61   csum = 0x30A65ABD
   62..63   cbData = 0x0097 (151 bytes)
   64..65   cbUncomp = 0x0097 (151 bytes)
   66..FD   ab[0x0097] = uncompressed file data
</pre>

		<h3 class="dtH1">
			<a id="notes"></a>Notes</h3>

		<h4 class="dtH1">
			<a id="chksum"></a>Checksum Method</h4>

		<p>The computation and verification of checksums found in <code>CFDATA</code> entries cabinet files is done using a function named <code>CSUMCompute</code>. Its actual source code is provided for reference. When checksums are not supplied by the cabinet file creating application, the checksum field is set to zero. Cabinet extracting applications do not compute or verify the checksum if the field is set to zero.</p>

		<pre class="code">CHECKSUM CSUMCompute(void *pv, UINT cb, CHECKSUM seed)
{
	int         cUlong;                 // Number of ULONGs in block
	CHECKSUM    csum;                   // Checksum accumulator
	BYTE       *pb;
	ULONG       ul;

	cUlong = cb / 4;                    // Number of ULONGs
	csum = seed;                        // Init checksum
	pb = pv;                            // Start at front of data block

	//** Checksum integral multiple of ULONGs
	while (cUlong-- &gt; 0) {
		//** NOTE: Build ULONG in big/little-endian independent manner
		ul = *pb++;                     // Get low-order byte
		ul |= (((ULONG)(*pb++)) &lt;&lt;  8); // Add 2nd byte
		ul |= (((ULONG)(*pb++)) &lt;&lt; 16); // Add 3nd byte
		ul |= (((ULONG)(*pb++)) &lt;&lt; 24); // Add 4th byte

		csum ^= ul;                     // Update checksum
	}

	//** Checksum remainder bytes
	ul = 0;
	switch (cb % 4) {
		case 3:
			ul |= (((ULONG)(*pb++)) &lt;&lt; 16); // Add 3nd byte
		case 2:
			ul |= (((ULONG)(*pb++)) &lt;&lt;  8); // Add 2nd byte
		case 1:
			ul |= *pb++;                    // Get low-order byte
		default:
			break;
	}
	csum ^= ul;                         // Update checksum

	//** Return computed checksum
	return csum;
}</pre>

		<p>The checksums for non-split <code>CFDATA</code> blocks are computed first on the compressed data bytes, then on the <code>CFDATA</code> header area, starting at the <code>CFDATA.cbData</code> field:</p>

		<pre class="code">CFDATA.cbData = cbCompressed;
CFDATA.cbUncomp = cbUncompressed;
csumPartial = CSUMCompute(&amp;CFDATA.ab[0],CFDATA.cbData,0);
CFDATA.csum = CSUMCompute(&amp;CFDATA.cbData,sizeof(CFDATA) –
sizeof(CFDATA.csum),csumPartial);</pre>

		<p>When blocks are split across cabinet file boundaries, the checksum for the partial block at the end of a cabinet file is computed first on the partial field of compressed data bytes, then on the header:</p>

		<pre class="code">CFDATA.cbData = cbPartialData;
CFDATA.cbUncomp = 0;
csumPartial = CSUMCompute(&amp;CFDATA.ab[0],cbPartialData,0);
CFDATA.csum = CSUMCompute(&amp;CFDATA.cbData,sizeof(CFDATA) –
sizeof(CFDATA.csum),csumPartial);</pre>

		<p>The checksum for the residual block in the next cabinet file is computed first on the remainder of the field of compressed data bytes, then on the header:</p>

		<pre class="code">CFDATA.cbData = cbResidualData;
CFDATA.cbUncomp = cbUncompressed;
csumPartial = CSUMCompute(&amp;CFDATA.ab[cbPartialData],cbResidualData,0);
CFDATA.csum = CSUMCompute(&amp;CFDATA.cbData,sizeof(CFDATA) –
sizeof(CFDATA.csum),csumPartial);</pre>

		<h4 class="dtH1">
			<a id="utf_enc"></a>UTF Encoding Method</h4>

		<p>UTF (universal text format) is used to compactly represent a broad range of Unicode characters while favoring size for the most common characters. Unicode characters are translated to sequences of one, two, or three bytes per character.</p>

		<p>When a string containing Unicode characters larger than 0x007F are encoded in the <code>CFFILE.szName</code> field, the <code>_A_NAME_IS_UTF</code> attribute should be included in the file's attributes. When no characters larger than 0x007F are in the name, the <code>_A_NAME_IS_UTF</code> attribute should not be set. If byte values larger than 0x7F are found in <code>CFFILE.szName</code>, but the <code>_A_NAME_IS_UTF</code> attribute is not set, the characters should be interpreted according to the current locale.</p>

		<p>Unicode characters with values 0x0000 through 0x007F are represented by a single byte of the same value.</p>

		<p>The first byte emitted for Unicode characters 0x0080 through 0x07FF is <code>0xC0+(unicodevalue &gt;&gt; 6)</code>, and the second byte is <code>0x80+(unicodevalue &amp; 0x003F)</code>.</p>

		<p>Unicode characters 0x0800 through 0xFFFF are represented by byte1 = <code>0xE0+(unicodevalue &gt;&gt; 12)</code>, byte2 = <code>0x80+((unicodevalue &gt;&gt; 6) &amp; 0x3F)</code>, and byte3 = <code>0x80+(unicodevalue &amp; 0x3F)</code>.</p>

		<h2 class="dtH1">
			<a id="top"></a>
			<a id="microsoftfcifdilibrarydescription"></a>Microsoft FCI/FDI Library Description</h2>

		<p>Copyright © 1996-1997 Microsoft Corporation. All rights reserved.</p>

		<h4 class="dtH1">Topics in this section</h4>

		<p><a href="#fcifdiintro">Introduction</a> </p>

		<p><a href="#fci">FCI</a>

		</p>
		<ul>
			<li><a href="#fcicreate">FCICreate</a> </li>

			<li><a href="#fciadd">FCIAddFile</a> </li>

			<li><a href="#fciflushcabinet">FCIFlushCabinet</a> </li>

			<li><a href="#fciflushfolder">FCIFlushFolder</a> </li>

			<li><a href="#fcidestroy">FCIDestroy</a> </li>
		</ul>

		<p><a href="#fdi">FDI</a>

		</p>
		<ul>
			<li><a href="#fdicreate">FDICreate</a> </li>

			<li><a href="#fdiiscab">FDIIsCabinet</a> </li>

			<li><a href="#fdicopy">FDICopy</a> </li>

			<li><a href="#fdidestroy">FDIDestroy</a> </li>
		</ul>

		<h3 class="dtH1">
			<a id="fcifdiintro"></a>Introduction</h3>

		<p>The FCI (File Compression Interface) and FDI (File Decompression Interface) libraries provide the ability to create and extract files from cabinets (also known as "CAB files"). In addition, the libraries provide compression and decompression capability to reduce the size of file data stored in cabinets.</p>

		<p>The FCI and FDI functions are available through cabinet.dll.</p>

		<p>FCI and FDI support multiple simultaneous contexts, so it is possible to create or extract multiple cabinets simultaneously within the same application. If the application is multi-threaded, it is also possible to run a different context in each thread; however, it is not permitted for the application to use the <em>same</em> context simultaneously in multiple threads (e.g. one cannot call FCIAddFile from two different threads, using the same FCI context).</p>

		<p>FCI and FDI operate using the technique of function callbacks; some of the parameters of the FCI and FDI APIs are pointers to functions in the client application. The parameters and purpose of these functions are explained fully in this document. The <em>fci_int.h</em> and <em>fd_int.h</em> header files provide macros for declaring the callback functions, and use keywords such HUGE, FAR, and DIAMONDAPI, which ensure that the functions are properly defined for both 32-bit and 16-bit operation. For example, in the case of the memory allocation and memory free functions, the following definitions exist in <em>fci_int.h</em>:</p>

		<pre class="code">#define FNFCIALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)
#define FNFCIFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv)</pre>

		<p>These declarations can be used as follows:</p>

		<pre class="code">FNFCIALLOC(mem_alloc)
{
	  return malloc(cb);
}

FNFCIFREE(mem_free)
{
	  return free(memory);
}

some_function()
{
	  hfci = FCICreate(
			&amp;erf, 
			filedest, 
			mem_alloc, 
			mem_free,
			etc.
	  );
}
</pre>

		<p>It should be noted that the FCI callback function names all begin with the string "FCI". In addition, the FCI and FDI i/o functions (open, close, read, write, seek) take different parameters, and cannot be used interchangeably. </p>

		<p>The FDI i/o functions take parameters which are identical to those of the C run-time library routines _open, close, read, write, and lseek. The FCI i/o functions take similar parameters, with the addition of an error pointer in which to return an i/o error, and the client's context pointer originally passed in to the FCICreate API.</p>

		<p>Two example applications are provided; <em>testfci</em> and <em>testfdi</em>. These applications demonstrate how all of the FCI and FDI APIs, respectively, may be used.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<h3 class="dtH1">
			<a id="fci"></a>FCI</h3>

		<p>The five FCI (File Compression Interface) APIs are:</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">API</th>
						<th scope="col">Description</th>
					</tr>

					<tr>
						<td class="normal" data-th="API"><a href="#fcicreate">FCICreate</a><strong> </strong></td>
						<td data-th="Description">Create an FCI context</td>
					</tr>

					<tr>
						<td class="normal" data-th="API"><a href="#fciadd">FCIAddFile</a><strong> </strong></td>
						<td data-th="Description">Add a file to the cabinet under construction</td>
					</tr>

					<tr>
						<td class="normal" data-th="API"><a href="#fciflushcabinet">FCIFlushCabinet</a><strong> </strong></td>
						<td data-th="Description">Complete the current cabinet</td>
					</tr>

					<tr>
						<td class="normal" data-th="API"><a href="#fciflushfolder">FCIFlushFolder</a><strong> </strong></td>
						<td data-th="Description">Complete the current folder and start a new folder</td>
					</tr>

					<tr>
						<td class="normal" data-th="API"><a href="#fcidestroy">FCIDestroy</a><strong> </strong></td>
						<td data-th="Description">Destroy an FCI context</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<h4 class="dtH1">
			<a id="fcicreate"></a>FCICreate</h4>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<pre class="code">HFCI DIAMONDAPI FCICreate(
	  PERF               <em>perf</em>, 
	  PFNFCIFILEPLACED   <em>pfnfiledest</em>, 
	  PFNFCIALLOC        <em>pfnalloc</em>, 
	  PFNFCIFREE         <em>pfnfree</em>, 
	  PFNFCIOPEN         <em>pfnopen</em>, 
	  PFNFCIREAD         <em>pfnread</em>, 
	  PFNFCIWRITE        <em>pfnwrite</em>, 
	  PFNFCICLOSE        <em>pfnclose</em>, 
	  PFNFCISEEK         <em>pfnseek</em>, 
	  PFNFCIDELETE       <em>pfndelete</em>, 
	  PFNFCIGETTEMPFILE  <em>pfnfcigtf</em>, 
	  PCCAB              <em>pccab</em>, 
	  void FAR *         <em>pv</em> 
);
</pre>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fcicreate">FCICreate</a> </p>

		<h4 class="dtH1">
			<a id="fcicreate_param"></a>Parameters</h4>

		<p><em>perf</em></p>

		<blockquote class="dtBlock">
			Pointer to an error structure</blockquote>

		<p><em>pfnfiledest</em></p>

		<blockquote class="dtBlock">
			Function to call when a file is placed</blockquote>

		<p><em>pfnalloc</em></p>

		<blockquote class="dtBlock">
			Memory allocation function</blockquote>

		<p><em>pfnfree</em></p>

		<blockquote class="dtBlock">
			Memory free function</blockquote>

		<p><em>pfnopen</em></p>

		<blockquote class="dtBlock">
			Function to open a file</blockquote>

		<p><em>pfnread</em></p>

		<blockquote class="dtBlock">
			Function to read data from a file</blockquote>

		<p><em>pfnwrite</em></p>

		<blockquote class="dtBlock">
			Function to write data to a file</blockquote>

		<p><em>pfnclose</em></p>

		<blockquote class="dtBlock">
			Function to close a file</blockquote>

		<p><em>pfnseek</em></p>

		<blockquote class="dtBlock">
			Function to seek to a new position in a file</blockquote>

		<p><em>pfntemp</em></p>

		<blockquote class="dtBlock">
			Function to obtain a temporary file name</blockquote>

		<p><em>pfndelete</em></p>

		<blockquote class="dtBlock">
			Function to delete a file</blockquote>

		<p><em>pccab</em></p>

		<blockquote class="dtBlock">
			Parameters for creating cabinet</blockquote>

		<p><em>pv</em></p>

		<blockquote class="dtBlock">
			Client context parameter</blockquote>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fcicreate">FCICreate</a> </p>

		<h4 class="dtH1">
			<a id="fcicreate_descr"></a>Description</h4>

		<p>The <strong>FCICreate</strong> API creates an FCI context that is passed to other FCI APIs.</p>

		<p>The <em>perf</em> parameter should point to a global or allocated ERF structure. Any errors returned by <strong>FCICreate</strong> or subsequent FCI APIs using the same context will cause the ERF structure to be filled out.</p>

		<p>The <em>pfnalloc</em> and <em>pfnfree</em> parameters should point to memory allocation and memory free functions which will be called by FCI to allocate and free memory. These two functions take parameters identical to the standard C malloc and free functions.</p>

		<p>The <em>pfnopen</em>, <em>pfnread</em>, <em>pfnwrite</em>, <em>pfnclose</em>, <em>pfnseek</em>, and <em>pfndelete</em> parameters should point to functions which perform file open, file read, file write, file close, file seek, and file delete operations respectively. These functions must accept parameters similar to those for the standard <em>_open</em>, <em>_read</em>, <em>_write</em>, <em>_close</em>, <em>_lseek</em>, and <em>remove</em> functions, with the addition of two additional parameters to the list; err and pv. The err parameter is an <em>int *</em>, and upon entry into the function, <em>*err</em> will equal zero. However, if the function returns failure, <em>*err</em> should be set to an error code of the application's choosing, which will be returned via <em>perf</em> (the error code is not used by FCI, and is not required to conform to C run-time library <em>errno</em> conventions). The pv parameter will equal the client's context parameter passed in to <strong>FCICreate</strong>.</p>

		<p>The <em>pfntemp</em> parameter should point to a function which returns the name of a suitable temporary file. Three parameters will be passed to this function; pszTempName, an area of memory to store the filename, cbTempName, the size of the memory area, and pv, the client's context pointer. The filename returned by this function should not occupy more than cbTempName bytes. FCI may open several temporary files at once, so it is important to ensure that a different filename is returned each time, and that the file does not already exist. The function should return TRUE for success, or FALSE for failure.</p>

		<p>The <em>pfnfiledest</em> parameter should point to a function which will be called whenever the location of a file or file segment on a particular cabinet has been finalized. This information is useful only when files are being stored across multiple cabinets. The parameters passed to this function are pccab, a pointer to the CCAB structure of the cabinet on which the file has been stored, pszFile, the filename of the file which has been placed, cbFile, the file size, and fContinuation, a Boolean which signifies whether the file is a later segment of a file which has been split across cabinets. In addition, the client context value, pv, is also passed as a parameter.</p>

		<p>The <em>pccab</em> parameter should point to an initialized CCAB structure, which will provide FCI with details on how to build the cabinet. The CCAB fields are explained below:</p>

		<p>The cb field, the media size, specifies the maximum size of a cabinet which will be created by FCI. If necessary, multiple cabinets will be created. To ensure that only one cabinet is created, a sufficiently large number should be used for this parameter.</p>

		<p>The cbFolderThresh field specifies the maximum number of compressed bytes which may reside in a folder before a new folder is created. A higher folder threshold improves compression performance (since creating a new folder resets the compression history), but increases random access time to the folder.</p>

		<p>The iCab field is used by FCI to count the number of cabinets that have been created so far. This value can also be read by the application to determine the name of a cabinet. See the <em>GetNextCab</em> parameter of the <strong>FCIAddFile</strong> API for details.</p>

		<p>The iDisk field is used in a similar manner to iCab. See the <em>GetNextCab</em> parameter of the <strong>FCIAddFile</strong> API for details.</p>

		<p>The setID field is for the use of the application, and can be initialized with any number. The set ID is stored in the cabinet.</p>

		<p>The szDisk field should contain a disk-specific string (such as "Disk1", "Disk2", etc.) corresponding to the disk on which the cabinet is placed. Alternatively, if cabinets are not spanning multiple disks, the string can simply be a null string. This field is stored in the cabinet and is used upon extraction to prompt the user to insert the correct disk. See the <strong>FCIAddFile</strong> API for details.</p>

		<p>The szCab field should contain a string which contains the name of the first cabinet to be created (e.g. "APP1.CAB"). In the event of multiple cabinets being created, the <em>GetNextCab</em> function called by the <strong>FCIAddFile</strong> API allows subsequent cabinet names to be specified.</p>

		<p>The szCabPath field should contain the complete path of where to create the cabinet (e.g. "C:\MYFILES\").</p>

		<p>The <code>cbReserveCFHeader</code>, <code>cbReserveCFFolder</code>, and <code>cbReserveCFData</code> fields can be set to create per-cabinet, per-folder, and per-datablock reserved sections in the cabinet. For example, setting <code>cbReserveCFHeader</code> to 6144 is commonly used to reserve a 6k space in the cabinet file as needed for codesigning. The other reserved sections are not commonly used.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fcicreate">FCICreate</a> </p>

		<h4 class="dtH1">
			<a id="fcicreate_returns"></a>Returns</h4>

		<p>If successful, a non-NULL HFCI context pointer is returned. If unsuccessful, NULL is returned, and the error structure pointed to by <em>perf</em> is filled out.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fcicreate">FCICreate</a> </p>

		<h4 class="dtH1">
			<a id="fciadd"></a>FCIAddFile</h4>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<pre class="code">BOOL DIAMONDAPI FCIAddFile(
	  HFCI                  <em>hfci</em>, 
	  char                 *<em>pszSourceFile</em>, 
	  char                 *<em>pszFileName</em>, 
	  BOOL                  <em>fExecute</em>, 
	  PFNFCIGETNEXTCABINET  <em>GetNextCab</em>, 
	  PFNFCISTATUS          <em>pfnProgress</em>, 
	  PFNFCIGETOPENINFO     <em>pfnOpenInfo</em>, 
	  TCOMP                 <em>typeCompress</em> 
);
</pre>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciadd">FCIAddFile</a> </p>

		<h4 class="dtH1">
			<a id="fciadd_param"></a>Parameters</h4>

		<p><em>hfci</em></p>

		<blockquote class="dtBlock">
			FCI Context pointer originally returned by <strong>FCICreate</strong></blockquote>

		<p><em>pszSourceFile</em></p>

		<blockquote class="dtBlock">
			Name of file to add (should include path information)</blockquote>

		<p><em>pszFileName</em></p>

		<blockquote class="dtBlock">
			Name under which to store the file in the cabinet fExecute
		</blockquote>

		<blockquote class="dtBlock">
			Boolean indicating whether the file should be executed when it is extracted</blockquote>

		<p><em>GetNextCab</em></p>

		<blockquote class="dtBlock">
			Function called to obtain specifications on the next cabinet to create</blockquote>

		<p><em>pfnProgress</em></p>

		<blockquote class="dtBlock">
			Progress function called to update the user</blockquote>

		<p><em>pfnOpenInfo</em></p>

		<blockquote class="dtBlock">
			Function called to open a file and return file date, time and attributes</blockquote>

		<p><em>typeCompress</em></p>

		<blockquote class="dtBlock">
			Compression type to use</blockquote>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciadd">FCIAddFile</a> </p>

		<h4 class="dtH1">
			<a id="fciadd_descr"></a>Description</h4>

		<p>The <strong>FCIAddFile</strong> API adds a file to the cabinet under construction.</p>

		<p>The <em>hfci</em> parameter must be the context pointer returned by a previous call to <strong>FCICreate</strong>.</p>

		<p>The <em>pszSourceFile</em> parameter specifies the location of the file to be added to the cabinet, and should therefore include as much path information as possible (e.g. "C:\MYFILES\TEST.EXE").</p>

		<p>The <em>pszFileName</em> parameter specifies the name of the file inside the cabinet, and should not include any path information (e.g. "TEST.EXE").</p>

		<p>The <em>fExecute</em> parameter specifies whether the file should be executed automatically when the cabinet is extracted. When set, the _A_EXEC attribute will be added to the file entry in the CAB. This mechanism is used in some Microsoft self-extracting executables, and could be used for this purpose in any custom extract application.</p>

		<p>The <em>GetNextCab</em> parameter should point to a function which is called whenever FCI wishes to create a new cabinet, which will happen whenever the size of the cabinet is about to exceed the media size as specified in the cb field of the CCAB structure passed to <strong>FCICreate</strong>. The <em>GetNextCab</em> function is called with three parameters which are explained below:</p>

		<p>The first parameter, pccab, is a pointer to a copy of the CCAB structure of the cabinet which has just been completed. However, the iCab field will have been incremented by one. When this function returns, the next cabinet will be created using the fields in this structure, so these fields should be modified as is necessary. In particular, the szCab field (the cabinet name) should be changed. If creating multiple cabinets, typically the iCab field is used to create the name; for example, the <em>GetNextCab</em> function might include a line that does:</p>

		<pre class="code">sprintf(pccab-&gt;szCab, "FOO%d.CAB", pccab-&gt;iCab);</pre>

		<p>Similarly, the disk name, media size, folder threshold, etc. parameters may also be modified.</p>

		<p>The second parameter, cbPrevCab, is an estimate of the size of the cabinet which has just been completed.</p>

		<p>The last parameter, pv, is the application-defined value originally passed to <strong>FCICreate</strong>.</p>

		<p>The <em>GetNextCab</em> function should return TRUE for success, or FALSE to abort cabinet creation.</p>

		<p>The <em>pfnProgress</em> parameter should point to a function that is called periodically by FCI so that the application may send a progress report to the user. The progress function has four parameters; typeStatus, which specifies the type of status message, cb1 and cb2, which are numbers, the meaning of which is dependent upon typeStatus, and pv, the application-specific context pointer. </p>

		<p>The typeStatus parameter may take on values of <strong><em>statusFile</em></strong>, <strong><em>statusFolder</em></strong>, or <strong><em>statusCabinet</em></strong>. If typeStatus equals <strong><em>statusFile</em></strong> then it means that FCI is compressing data blocks into a folder. In this case, cb1 is either zero, or the compressed size of the most recently compressed block, and cb2 is either zero, or the uncompressed size of the most recently read block (which is usually 32K, except for the last block in a folder, which may be smaller). There is <em>no</em> direct relation between cb1 and cb2; FCI may read several blocks of uncompressed data before emitting any compressed data; if this happens, some <strong><em>statusFile</em></strong> messages may contain, for example, cb1 = 0 and cb2 = 32K, followed later by other messages which contain cb1 = 20K and cb2 = 0.</p>

		<p>If typeStatus equals <strong><em>statusFolder</em></strong> then it means that FCI is copying a folder to a cabinet, and cb1 is the amount copied so far, and cb2 is the total size of the folder. Finally, if typeStatus equals <strong><em>statusCabinet</em></strong>, then it means that FCI is writing out a completed cabinet, and cb1 is the estimated cabinet size that was previously passed to <em>GetNextCab</em>, and cb2 is the actual resulting cabinet size.</p>

		<p>The progress function should return 0 for success, or -1 for failure, with an exception in the case of <strong><em>statusCabinet</em></strong> messages, where the function should return the desired cabinet size (<em>cb2</em>), or possibly a value rounded up to slightly higher than that.</p>

		<p>The <em>pfnOpenInfo</em> parameter should point to a function which opens a file and returns its datestamp, timestamp, and attributes. The function will receive five parameters; pszName, the complete pathname of the file to open; pdate, a memory location to return a FAT-style date code; ptime, a memory location to return a FAT-style time code; pattribs, a memory location to return FAT-style attributes; and pv, the application-specific context pointer originally passed to <strong>FCICreate</strong>. The function should open the file using a file open function compatible with those passed in to <strong>FCICreate</strong>, and return the resulting file handle, or -1 if unsuccessful.</p>

		<p>The <em>typeCompress</em> parameter specifies the type of compression to use, which may be either <strong><em>tcompTYPE_NONE</em></strong> for no compression, or<em> <strong>tcompTYPE_MSZIP</strong></em> for Microsoft ZIP compression. Other compression formats may be supported in the future.<br> Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciadd">FCIAddFile</a> </p>

		<h4 class="dtH1">
			<a id="fciadd_returns"></a>Returns</h4>

		<p>If successful, TRUE is returned. If unsuccessful, FALSE is returned, and the error structure pointed to by <em>perf</em> (from <strong>FCICreate</strong>) is filled out.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciadd">FCIAddFile</a> </p>

		<h4 class="dtH1">
			<a id="fciflushcabinet"></a>FCIFlushCabinet</h4>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<pre class="code">BOOL DIAMONDAPI FCIFlushCabinet(
	  HFCI                  <em>hfci</em>, 
	  BOOL                  <em>fGetNextCab</em>, 
	  PFNFCIGETNEXTCABINET  <em>GetNextCab</em>, 
	  PFNFCISTATUS          <em>pfnProgress</em> 
);
</pre>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciflushcabinet">FCIFlushCabinet</a> </p>

		<pre class="code"><a id="fciflushcabinet_param"></a>Parameters</pre>

		<p><em>hfci</em></p>

		<blockquote class="dtBlock">
			FCI Context pointer originally returned by <strong>FCICreate</strong></blockquote>

		<p><em>fGetNextCab</em></p>

		<blockquote class="dtBlock">
			Specifies whether the function pointed to by the supplied GetNextCab parameter, will be called</blockquote>

		<p><em>GetNextCab</em></p>

		<blockquote class="dtBlock">
			Function called to obtain specifications on the next cabinet to create</blockquote>

		<p><em>pfnProgress</em></p>

		<blockquote class="dtBlock">
			Progress function called to update the user</blockquote>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciflushcabinet">FCIFlushCabinet</a> </p>

		<h4 class="dtH1">
			<a id="fciflushcabinet_descr"></a>Description</h4>

		<p>The <strong>FCIFlushCabinet</strong> API forces the current cabinet under construction to be completed immediately and written to disk. Further calls to <strong>FCIAddFile</strong> will cause files to be added to another cabinet. It is also possible that there exists pending data in FCI's internal buffers that will may require spillover into another cabinet, if the current cabinet has reached the application-specified media size limit.</p>

		<p>The <em>hfci</em> parameter must be the context pointer returned by a previous call to <strong>FCICreate</strong>.</p>

		<p>The <em>fGetNextCab</em> flag determines whether the function pointed to by the supplied <em>GetNextCab</em> parameter, will be called. If <em>fGetNextCab</em> is TRUE, then <em>GetNextCab</em> will be called to obtain continuation information. Otherwise, if <em>fGetNextCab</em> is FALSE, then <em>GetNextCab</em> will be called only if the cabinet overflows.</p>

		<p>The <em>pfnProgress</em> parameter should point to a function which is called periodically by FCI so that the application may send a progress report to the user. This function works in an identical manner to the progress function passed to <strong>FCIAddFile</strong>.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciflushcabinet">FCIFlushCabinet</a> </p>

		<h4 class="dtH1">
			<a id="fciflushcabinet_returns"></a>Returns</h4>

		<p>If successful, TRUE is returned. If unsuccessful, FALSE is returned, and the error structure pointed to by <em>perf</em> (from <strong>FCICreate</strong>) is filled out.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciflushcabinet">FCIFlushCabinet</a> </p>

		<h4 class="dtH1">
			<a id="fciflushfolder"></a>FCIFlushFolder</h4>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<pre class="code">BOOL DIAMONDAPI FCIFlushFolder(
	  HFCI                  <em>hfci</em>, 
	  PFNFCIGETNEXTCABINET  <em>GetNextCab</em>, 
	  PFNFCISTATUS          <em>pfnProgress</em> 
);
</pre>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciflushfolder">FCIFlushFolder</a> </p>

		<h4 class="dtH1">
			<a id="fciflushfolder_param"></a>Parameters</h4>

		<p><em>hfci</em></p>

		<blockquote class="dtBlock">
			FCI Context pointer originally returned by <strong>FCICreate</strong></blockquote>

		<p><em>GetNextCab</em></p>

		<blockquote class="dtBlock">
			Function called to obtain specifications on the next cabinet to create</blockquote>

		<p><em>pfnProgress</em></p>

		<blockquote class="dtBlock">
			Progress function called to update the user</blockquote>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciflushfolder">FCIFlushFolder</a> </p>

		<h4 class="dtH1">
			<a id="fciflushfolder_descr"></a>Description</h4>

		<p>The <strong>FCIFlushFolder</strong> API forces the current folder under construction to be completed immediately, effectively resetting the compression history at this point (if compression is being used). </p>

		<p>The <em>hfci</em> parameter must be the context pointer returned by a previous call to <strong>FCICreate</strong>.</p>

		<p>The supplied <em>GetNextCab</em> function will be called if the cabinet overflows, which is a possibility if the pending data buffered inside FCI causes the application-specified cabinet media size to be exceeded.</p>

		<p>The <em>pfnProgress</em> parameter should point to a function which is called periodically by FCI so that the application may send a progress report to the user. This function works in an identical manner to the progress function passed to <strong>FCIAddFile</strong>.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fciflushfolder">FCIFlushFolder</a> </p>

		<h4 class="dtH1">
			<a id="fcidestroy"></a>FCIDestroy</h4>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<pre class="code">BOOL DIAMONDAPI FCIDestroy(
	  HFCI  hfci
);
</pre>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fcidestroy">FCIDestroy</a> </p>

		<h4 class="dtH1">
			<a id="fcidestroy_param"></a>Parameters</h4>

		<p><em>hfci</em></p>

		<blockquote class="dtBlock">
			FCI Context pointer originally returned by <strong>FCICreate</strong></blockquote>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fcidestroy">FCIDestroy</a> </p>

		<h4 class="dtH1">
			<a id="fcidestroy_descr"></a>Description</h4>

		<p>The <strong>FCIDestroy</strong> API destroys an <em>hfci</em> context, freeing any memory and temporary files associated with the context.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fcidestroy">FCIDestroy</a> </p>

		<h4 class="dtH1">
			<a id="fcidestroy_returns"></a>Returns</h4>

		<p>If successful, TRUE is returned. If unsuccessful, FALSE is returned. The only reason for failure is that the <em>hfci</em> passed in was not a proper context handle.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fci">FCI</a> &gt; <a href="#fcidestroy">FCIDestroy</a> </p>

		<h3 class="dtH1">
			<a id="fdi"></a>FDI</h3>

		<p>The five FDI (File Decompression Interface) APIs are:</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">API</th>
						<th scope="col">Description</th>
					</tr>

					<tr>
						<td class="normal" data-th="API"><a href="#fdicreate">FDICreate</a><strong> </strong></td>
						<td class="normal" data-th="Description"><strong>Create an FCI context</strong></td>
					</tr>

					<tr>
						<td class="normal" data-th="API"><a href="#fdiiscab">FDIIsCabinet</a><strong> </strong></td>
						<td class="normal" data-th="Description"><strong>Determines whether a file is a cabinet, and returns information if so</strong></td>
					</tr>

					<tr>
						<td class="normal" data-th="API"><a href="#fdicopy">FDICopy</a><strong> </strong></td>
						<td class="normal" data-th="Description"><strong>Extracts files from cabinets</strong></td>
					</tr>

					<tr>
						<td class="normal" data-th="API"><a href="#fdidestroy">FDIDestroy</a><strong> </strong></td>
						<td class="normal" data-th="Description"><strong>Destroy an FDI context</strong></td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<h4 class="dtH1">
			<a id="fdicreate"></a>FDICreate</h4>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<pre class="code">HFCI DIAMONDAPI FDICreate(
	  PFNALLOC  <em>pfnalloc</em>, 
	  PFNFREE   <em>pfnfree</em>, 
	  PFNOPEN   <em>pfnopen</em>, 
	  PFNREAD   <em>pfnread</em>, 
	  PFNWRITE  <em>pfnwrite</em>, 
	  PFNCLOSE  <em>pfnclose</em>, 
	  PFNSEEK   <em>pfnseek</em>, 
	  int       <em>cpuType</em>, 
	  PERF      <em>perf</em> 
);
</pre>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> </p>

		<h4 class="dtH1">
			<a id="fdicreate_param"></a>Parameters</h4>

		<p><em>pfnalloc</em></p>

		<blockquote class="dtBlock">
			Memory allocation function</blockquote>

		<p><em>pfnfree</em></p>

		<blockquote class="dtBlock">
			Memory free function</blockquote>

		<p><em>pfnopen</em></p>

		<blockquote class="dtBlock">
			Function to open a file</blockquote>

		<p><em>pfnread</em></p>

		<blockquote class="dtBlock">
			Function to read data from a file</blockquote>

		<p><em>pfnwrite</em></p>

		<blockquote class="dtBlock">
			Function to write data to a file</blockquote>

		<p><em>pfnclose</em></p>

		<blockquote class="dtBlock">
			Function to close a file</blockquote>

		<p><em>pfnseek</em></p>

		<blockquote class="dtBlock">
			Function to seek to a new position in a file</blockquote>

		<p><em>cpuType</em></p>

		<blockquote class="dtBlock">
			Type of CPU</blockquote>

		<p><em>perf</em></p>

		<blockquote class="dtBlock">
			Pointer to an error structure</blockquote>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdicreate">FDICreate</a> </p>

		<h4 class="dtH1">
			<a id="fdicreate_descr"></a>Description</h4>

		<p>The <strong>FDICreate</strong> API creates an FDI context that is passed to other FDI APIs. </p>

		<p>The <em>pfnalloc</em> and <em>pfnfree</em> parameters should point to memory allocation and memory free functions which will be called by FDI to allocate and free memory. These two functions take parameters identical to the standard C malloc and free functions.</p>

		<p>The <em>pfnopen</em>, <em>pfnread</em>, <em>pfnwrite</em>, <em>pfnclose</em>, and <em>pfnseek</em> parameters should point to functions which perform file open, file read, file write, file close, and file seek operations respectively. These functions should accept parameters identical to those for the standard <em>_open</em>, <em>_read</em>, <em>_write</em>, <em>_close</em>, and <em>_lseek</em> functions, and should likewise have identical return codes. Note that the FDI i/o functions do not take the same parameters as the FCI i/o functions.</p>

		<p>It is not necessary for these functions to actually call _open etc.; these functions could instead call fopen, fread, fwrite, fclose, and fseek, or CreateFile, ReadFile, WriteFile, CloseHandle, and SetFilePointer, etc. However, the parameters and return codes will have to be translated appropriately (e.g. the file open mode passed in to <em>pfnopen</em>).</p>

		<p>The <em>cpuType</em> parameter should equal one of <strong><em>cpu80386</em></strong> (indicating that 80386 instructions may be used), <strong><em>cpu80286</em></strong> (indicating that only 80286 instructions may be used), or <strong><em>cpuUNKNOWN</em></strong> (indicating that FDI should determine the CPU type). The <em>cpuType</em> parameter is looked at only by the 16-bit version of FDI; it is ignored by the 32-bit version of FDI.</p>

		<p>The <em>perf</em> parameter should point to a global or allocated ERF structure. Any errors returned by <strong>FDICreate</strong> or subsequent FDI APIs using the same context will cause the ERF structure to be filled out.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdicreate">FDICreate</a> </p>

		<h4 class="dtH1">
			<a id="fdicreate_returns"></a>Returns</h4>

		<p>If successful, a non-NULL HFDI context pointer is returned. If unsuccessful, NULL is returned, and the error structure pointed to by <em>perf</em> is filled out.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdicreate">FDICreate</a> </p>

		<h4 class="dtH1">
			<a id="fdiiscab"></a>FDIIsCabinet</h4>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<pre class="code">BOOL DIAMONDAPI FDIIsCabinet(
	  HFDI             <em>hfdi</em>, 
	  int              <em>hf</em>, 
	  PFDICABINETINFO  <em>pfdici</em> 
);
</pre>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdiiscab">FDIIsCabinet</a> </p>

		<h4 class="dtH1">
			<a id="fdiiscab_param"></a>Parameters</h4>

		<p><em>hfdi</em></p>

		<blockquote class="dtBlock">
			FDI Context pointer originally returned by <strong>FDICreate</strong></blockquote>

		<p><em>hf</em></p>

		<blockquote class="dtBlock">
			File handle returned by a call to the application's file open function</blockquote>

		<p><em>pfdici</em></p>

		<blockquote class="dtBlock">
			Pointer to a cabinet info structure</blockquote>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdiiscab">FDIIsCabinet</a> </p>

		<h4 class="dtH1">
			<a id="fdiiscab_descr"></a>Description</h4>

		<p>The <strong>FDIIsCabinet</strong> API determines whether a given file is a cabinet, and if so, returns information about the cabinet in the provided FDICABINETINFO structure.</p>

		<p>The <em>hfdi</em> parameter is the context pointer returned by a previous call to <strong>FDICreate</strong>.</p>

		<p>The <em>hf</em> parameter must be a file handle on the file being examined. The file handle must be of the same type as those used by the file i/o functions passed to <strong>FDICreate</strong>.</p>

		<p>The <em>pfdici</em> parameter should point to an FDICABINETINFO structure, which will receive the cabinet details if the file is indeed a cabinet. The fields of this structure are as follows:</p>

		<p>The cbCabinet field contains the length of the cabinet file, in bytes. The cFolders field contains the number of folders in the cabinet. The cFiles field contains the total number of files in the cabinet. The setID field contains the set ID (an application-defined magic number) of the cabinet. The iCabinet field contains the number of this cabinet in the set (0 for the first cabinet, 1 for the second, and so forth). The fReserve field is a Boolean indicating whether there is a reserved area present in the cabinet. The hasprev field is a Boolean indicating whether this cabinet is chained to the previous cabinet, by way of having a file continued from the previous cabinet into the current one. The hasnext field is a Boolean indicating whether this cabinet is chained to the next cabinet, by way of having a file continued from this cabinet into the next one.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdiiscab">FDIIsCabinet</a> </p>

		<h4 class="dtH1">
			<a id="fdiiscab_returns"></a>Returns</h4>

		<p>If the file is a cabinet, then TRUE is returned and the FDICABINETINFO structure is filled out. If the file is not a cabinet, or some other error occurred, then FALSE is returned. In either case, it is the responsibility of the application to close the file handle passed to this function.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdiiscab">FDIIsCabinet</a> </p>

		<h4 class="dtH1">
			<a id="fdicopy"></a>FDICopy</h4>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<pre class="code">BOOL FAR DIAMONDAPI FDICopy(
		 HFDI           <em>hfdi</em>, 
   char  FAR           *<em>pszCabinet</em>, 
   char  FAR           *<em>pszCabPath</em>, 
   int                  <em>flags</em>, 
		 PFNFDINOTIFY   <em>pfnfdin</em>, 
		 PFNFDIDECRYPT  <em>pfnfdid</em>, 
   void  FAR           *<em>pvUser</em> 
);
</pre>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdicopy">FDICopy</a> </p>

		<h4 class="dtH1">
			<a id="fdicopy_param"></a>Parameters</h4>

		<p><em>hfdi</em></p>

		<blockquote class="dtBlock">
			FDI Context pointer originally returned by <strong>FDICreate</strong></blockquote>

		<p><em>pszCabinet</em></p>

		<blockquote class="dtBlock">
			Name of cabinet file, excluding path information</blockquote>

		<p><em>pszCabPath</em></p>

		<blockquote class="dtBlock">
			File path to cabinet file</blockquote>

		<p><em>flags</em></p>

		<blockquote class="dtBlock">
			Flags to control the extract operation</blockquote>

		<p><em>pfnfdin</em></p>

		<blockquote class="dtBlock">
			Pointer to a notification (status update) function</blockquote>

		<p><em>pfnfdid</em></p>

		<blockquote class="dtBlock">
			Pointer to a decryption function</blockquote>

		<p><em>pvUser</em></p>

		<blockquote class="dtBlock">
			Application-specified value to pass to notification function</blockquote>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdicopy">FDICopy</a> </p>

		<h4 class="dtH1">
			<a id="fdicopy_descr"></a>Description</h4>

		<p>The <strong>FDICopy</strong> API extracts one or more files from a cabinet. Information on each file in the cabinet is passed back to the supplied pfnfdin function, at which point the application may decide to extract or not extract the file.</p>

		<p>The <em>hfdi</em> parameter is the context pointer returned by a previous call to <strong>FDICreate</strong>.</p>

		<p>The <em>pszCabinet</em> parameter should be the name of the cabinet file, excluding any path information, from which to extract files. If a file is split over multiple cabinets, <strong>FDICopy</strong> does allow subsequent cabinets to be opened.</p>

		<p>The <em>pszCabPath</em> parameter should be the file path of the cabinet file (e.g. "C:\MYCABS\"). The contents of <em>pszCabPath</em> and <em>pszCabinet</em> will be strung together to create the full pathname of the cabinet.</p>

		<p>The <em>flags</em> parameter is used to set flags for the decoder. At this time there are no flags defined, and the <em>flags</em> parameter should be set to zero.</p>

		<p>The <em>pfnfdin</em> parameter should point to a file notification function, which will be called periodically to update the application on the status of the decoder. The <em>pfnfdin</em> function takes two parameters; fdint, an integral value indicating the type of notification message, and pfdin, a pointer to an FDINOTIFICATION structure.</p>

		<p>The fdint parameter may equal one of the following values; <strong><em>fdintCABINET_INFO</em></strong> (general information about the cabinet),<strong><em> fdintPARTIAL_FILE</em></strong> (the first file in the cabinet is a continuation from a previous cabinet), <strong><em>fdintCOPY_FILE</em></strong> (asks the application if this file should be copied), <strong><em>fdintCLOSE_FILE_INFO</em></strong> (close the file and set file attributes, date, etc.), or<strong><em> fdintNEXT_CABINET</em></strong> (file continued on next cabinet). </p>

		<p>The pfdin parameter will point to an FDINOTIFICATION structure with some or all of the fields filled out, depending on the value of the fdint parameter. Four of the fields are used for general data; cb (a long integer), and psz1, psz2, and psz3 (pointers to strings), the meanings of which are highly dependent on the fdint value. The pv field will be the value the application originally passed in as the <em>pvUser</em> parameter to <strong>FDICopy</strong>.</p>

		<p>The <em>pfnfdin</em> function must return a value to FDI, which tells FDI whether to continue, abort, skip a file, or perform some other operation. The values that can be returned depend on fdint, and are explained below.</p>

		<p>Note that it is possible that future versions of FDI will have additional notification messages. Therefore, the application should ignore values of fdint it does not understand, and return zero to continue (preferably), or -1 (negative one) to abort.</p>

		<p>If fdint equals <strong><em>fdintCABINET_INFO</em></strong> then the following fields will be filled out; psz1 will point to the name of the next cabinet (excluding path information); psz2 will point to the name of the next disk; psz3 will point to the cabinet path name; setID will equal the set ID of the current cabinet; and iCabinet will equal the cabinet number within the cabinet set (0 for the first cabinet, 1 for the second cabinet, etc.) The application should return 0 to indicate success, or -1 to indicate failure, which will abort <strong>FDICopy</strong>. An <strong><em>fdintCABINET_INFO</em></strong> notification will be provided exactly once for each cabinet opened by <strong>FDICopy</strong>, including continuation cabinets opened due to files spanning cabinet boundaries.</p>

		<p>If fdint equals <strong><em>fdintCOPY_FILE</em></strong> then the following fields will be filled out; psz1 will point to the name of a file in the cabinet; cb will equal the uncompressed size of the file; date will equal the file's 16-bit FAT date; time will equal the file's 16-bit FAT time; and attribs will equal the file's 16-bit FAT attributes. The application may return one of three values; 0 (zero) to skip (i.e. not copy) the file; -1 (negative one) to abort <strong>FDICopy</strong>; or a non-zero (and non-negative-one) file handle for the destination to which to write the file. The file handle returned must be compatible with the PFNCLOSE function supplied to <strong>FDICreate</strong>. The <strong><em>fdintCOPY_FILE</em></strong> notification is called for each file that <em>starts</em> in the current cabinet, providing the opportunity for the application to request that the file be copied or skipped.</p>

		<p>If fdint equals <strong><em>fdintCLOSE_FILE_INFO</em></strong> then the following fields will be filled out; psz1 will point to the name of a file in the cabinet; hf will be a file handle (which originated from <strong><em>fdintCOPY_FILE</em></strong>); date will equal the file's 16-bit FAT date; time will equal the file's 16-bit FAT time; attributes will equal the file's 16-bit FAT attributes (minus the _A_EXEC bit); and cb will equal either zero (0) or one (1), indicating whether the file should be executed after extract (one), or not (zero). It is the responsibility of the application to execute the file if cb equals one. The<strong><em> fdintCLOSE_FILE_INFO</em></strong> notification is called after all of the data has been written to a target file. The application must close the file (using the provided hf handle), and set the file date, time, and attributes. The application should return TRUE for success, or FALSE or -1 (negative one) to abort <strong>FDICopy</strong>. FDI assumes that the target file was closed, even if this callback returns failure; FDI will not attempt to use PFNCLOSE to close the file.</p>

		<p>If fdint equals <strong><em>fdintPARTIAL_FILE</em></strong> then the following fields will be filled out; psz1 will point to the name of the file continued from a previous cabinet; psz2 will point to the name of the cabinet on which the first segment of the file exists; psz3 will point to the name of the disk on which the first segment of the file exists. The <strong><em>fdintPARTIAL_FILE</em></strong> notification is called for files at the beginning of a cabinet which are continued from a previous cabinet. This notification will occur only when <strong>FDICopy</strong> is started on the second or subsequent cabinet in a series, which has files continued from a previous cabinet. The application should return zero (0) for success, or -1 (negative one) for failure, which will abort <strong>FDICopy</strong>.</p>

		<p>If fdint equals <strong><em>fdintNEXT_CABINET</em></strong> then the following fields will be filled out; psz1 will point to the name of the next cabinet on which the current file is continued; psz2 will point to the name of the next disk on which the current file is continued; psz3 will point to the cabinet path information; and fdie will equal a success or error value. The <strong><em>fdintNEXT_CABINET</em></strong> notification is called only when <strong><em>fdintCOPY_FILE</em></strong> was instructed to copy a file in the current cabinet that is continued in a subsequent cabinet. It is important that the cabinet path name, psz3, be validated before returning (psz3, which points to a 256 byte array, may be modified by the application; however, it is not permissible to modify psz1 or psz2). The application should ensure that the cabinet exists and is readable before returning; if necessary, the application should issue a disk change prompt and ensure that the cabinet file exists. When this function returns to FDI, FDI will verify that the setID and iCabinet fields of the supplied cabinet match the expected values for that cabinet. If not, FDI will continue to send <strong><em>fdintNEXT_CABINET</em></strong> notification messages with the fdie field set to <strong><em>FDIERROR_WRONG_CABINET</em></strong>, until the correct cabinet file is specified, or until this function returns -1 (negative one) to abort the <strong>FDICopy</strong> call. If after returning from this function, the cabinet file is not present and readable, or has been damaged, then the fdie field will equal one of the following values; <strong><em>FDIERROR_CABINET_NOT_FOUND</em></strong>, <strong><em>FDIERROR_NOT_A_CABINET</em></strong>, <strong><em>FDIERROR_UNKNOWN_CABINET_VERSION</em></strong>, <strong><em>FDIERROR_CORRUPT_CABINET</em></strong>, <strong><em>FDIERROR_BAD_COMPR_TYPE</em></strong>, <strong><em>FDIERROR_RESERVE_MISMATCH</em></strong>, <strong><em>FDIERROR_WRONG_CABINET</em></strong>. If there was no error, fdie will equal <strong><em>FDIERROR_NONE</em></strong>. The application should return 0 (zero) to indicate success, or -1 (negative one) to indicate failure, which will abort <strong>FDICopy</strong>.&nbsp;</p>

		<p>The <em>pfndid</em> parameter is reserved for encryption, and is currently not used by FDI. This parameter should be set to NULL.&nbsp;</p>

		<p>The <em>pvUser</em> parameter should contain an application-defined value that will be passed back as a field in the FDINOTIFICATION structure of the notification function. It not required, this field may be safely set to NULL.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdicopy">FDICopy</a> </p>

		<h4 class="dtH1">
			<a id="fdicopy_returns"></a>Returns</h4>

		<p>If successful, TRUE is returned. If unsuccessful, FALSE is returned, and the error structure pointed to by <em>perf</em> (from <strong>FDICreate</strong>) is filled out.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdicopy">FDICopy</a> </p>

		<h4 class="dtH1">
			<a id="fdidestroy"></a>FCIDestroy</h4>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> </p>

		<pre class="code">BOOL DIAMONDAPI FDIDestroy(
	  HFDI  hfdi
);
</pre>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdidestroy">FDIDestroy</a> </p>

		<h4 class="dtH1">
			<a id="fdidestroy_param"></a>Parameters</h4>

		<p><em>hfdi</em></p>

		<blockquote class="dtBlock">
			FDI Context pointer originally returned by <strong>FDICreate</strong></blockquote>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdidestroy">FDIDestroy</a> </p>

		<h4 class="dtH1">
			<a id="fdidestroy_descr"></a>Description</h4>

		<p>The <strong>FDIDestroy</strong> API destroys an <em>hfdi</em> context, freeing any memory and temporary files associated with the context.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdidestroy">FDIDestroy</a> </p>

		<h4 class="dtH1">
			<a id="fdidestroy_returns"></a>Returns</h4>

		<p>If successful, TRUE is returned. If unsuccessful, FALSE is returned. The only reason for failure is that the <em>hfdi</em> passed in was not a proper context handle.</p>

		<p>Back to: <a href="#microsoftfcifdilibrarydescription">FCI/FDI Library</a> &gt; <a href="#fdi">FDI</a> &gt; <a href="#fdidestroy">FDIDestroy</a> </p>

		<h2 class="dtH1">
			<a id="lzxdatacompressionformat"></a>Microsoft LZX Data Compression Format</h2>

		<p>Copyright © 1997 Microsoft Corporation. All rights reserved.</p>

		<h4 class="dtH1">Topics in this section</h4>

		<p><a href="#lzxintro">Introduction</a> </p>

		<p><a href="#concepts">Concepts</a> </p>

		<blockquote class="dtBlock">
			<a href="#lz77">LZ77</a></blockquote>

		<blockquote class="dtBlock">
			<a href="#bitstream">Bitstream</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#win_size">Window Size</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#trees">Trees</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#rep_offsets">Repeated Offsets</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#const">Constants</a> </blockquote>

		<p><a href="#lzx_form">LZX Compressed Data Format</a> </p>

		<blockquote class="dtBlock">
			<a href="#cab_blk">Cabinet Block Size</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#head_struct">Header Structure</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#enc_preproc">Encoder Preprocessing</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#block_struct">Block Structure</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#uncomp_block_frmt">Uncompressed Block Format</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#vbtm_block">Verbatim Block</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#algn_off_block">Aligned Offset Block</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#tree_p_tree">Encoding the Trees and Pre-Trees</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#com_lit">Compressed Literals</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#match_off">Match Offset =&gt; Formatted Offset</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#form_off">Formatted Offset =&gt; Position Slot, Position Footer</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#pos_foot">Position Footer =&gt; Verbatim Bits, Aligned Offset Bits</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#match_length">Match Length =&gt; Length Header, Length Footer</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#length_head">Length Header, Position Slot =&gt; Length/Position Header</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#enc_match">Encoding a Match</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#dec_match">Decoding a Match or an Uncompressed Character</a> </blockquote>

		<h3 class="dtH1">
			<a id="lzxintro"></a>Introduction</h3>

		<p>This document is a design specification for the format of LZX compressed data used in the LZX compression mode of Microsoft's CAB file format. The purpose of this document is to allow anyone to encode or decode LZX compressed data. This document describes only the format of the output –it does not provide any specific algorithms for match location, tree generation, etc.</p>

		<p>Before proceeding with the design specification itself, a few important concepts are described in the following pages.</p>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> </p>

		<h3 class="dtH1">
			<a id="concepts"></a>Concepts</h3>

		<h4 class="dtH1">This section includes:</h4>

		<blockquote class="dtBlock">
			<a href="#lz77">LZ77</a></blockquote>

		<blockquote class="dtBlock">
			<a href="#bitstream">Bitstream</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#win_size">Window Size</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#trees">Trees</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#rep_offsets">Repeated Offsets</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#const">Constants</a> </blockquote>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> </p>

		<h4 class="dtH1">
			<a id="lz77"></a>LZ77</h4>

		<p>LZX is an LZ77 based compressor that uses static Huffman encoding and a sliding window of selectable size. Data symbols are encoded either as an uncompressed symbol, or as an (offset, length) pair indicating that <em>length</em> symbols should be copied from a displacement of -<em>offset</em> symbols from the current position in the output stream. The value of <em>offset</em> is constrained to be less than the size of the sliding window.</p>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#concepts">Concepts</a> </p>

		<h4 class="dtH1">
			<a id="bitstream"></a>Bitstream</h4>

		<p>An LZX bitstream is a sequence of 16 bit integers stored in the order least-significant-byte most-significant-byte. Given an input stream of bits named a, b, c, ..., x, y, z, A, B, C, D, E, F, the output byte stream (with byte boundaries highlighted) would be as shown below.</p>

		<p class="label"><strong>Output byte stream</strong></p>

		<p class="fig"><img id="bitstream" alt="Bb417343.bitstream(en-us,MSDN.10).gif" src="https://i-msdn.sec.s-msft.com/dynimg/IC47450.gif" title="Bb417343.bitstream(en-us,MSDN.10).gif" xmlns=""></p>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#concepts">Concepts</a> </p>

		<h4 class="dtH1">
			<a id="win_size"></a>Window Size</h4>

		<p>The window size must be a power of 2, from 2<span class="sup">15</span> to 2<span class="sup">21</span>. The window size is not stored in the compressed data stream, and must instead be passed to the decoder before decoding begins. </p>

		<p>The window size determines the number of window subdivisions, or "position slots", as shown in the following table:</p>

		<p class="label"><strong>Windows Size / Position Slot Table</strong></p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Window Size</th>
						<th scope="col">Position Slots Required</th>
					</tr>

					<tr>
						<td data-th="Window Size">32K</td>
						<td data-th="Position Slots Required">30</td>
					</tr>

					<tr>
						<td data-th="Window Size">64K</td>
						<td data-th="Position Slots Required">32</td>
					</tr>

					<tr>
						<td data-th="Window Size">128K</td>
						<td data-th="Position Slots Required">34</td>
					</tr>

					<tr>
						<td data-th="Window Size">256K</td>
						<td data-th="Position Slots Required">36</td>
					</tr>

					<tr>
						<td data-th="Window Size">512K</td>
						<td data-th="Position Slots Required">38</td>
					</tr>

					<tr>
						<td data-th="Window Size">1 MB</td>
						<td data-th="Position Slots Required">40</td>
					</tr>

					<tr>
						<td data-th="Window Size">2 MB</td>
						<td data-th="Position Slots Required">42</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#concepts">Concepts</a>
			<a id="trees"></a>Trees</p>

		<p>LZX uses canonical Huffman tree structures to represent elements. Huffman trees are well known in data compression and are not described here. Since an LZX decoder uses only the path lengths of the Huffman tree to reconstruct the identical tree, the following constraints are made on the tree structure:

		</p>
		<ol>
			<li>For any two elements with the same path length, the lower-numbered element must be further left on the tree than the higher numbered element. An alternative way of stating this constraint is that lower-numbered elements must have lower path traversal values; for example, 0010 (left-left-right-left) is lower than 0011 (left-left-right-right).</li>

			<li>For each level, starting at the deepest level of the tree and then moving upwards, leaf nodes must start as far left as possible. An alternative way of stating this constraint is that if any tree node has children then all tree nodes to the left of it with the same path length must also have children.</li>

			<li>Zero length Huffman codes are not permitted, therefore a tree must contain at least 2 elements. In the case where all tree elements are zero frequency, or all but one tree element is zero frequency, the resulting tree must consist of the two Huffman codes "0" and "1". In the latter case, constraint #1 still applies.</li>
		</ol>

		<p>LZX uses several Huffman tree structures. The most important tree is the <em>main</em> tree, which comprises 256 elements corresponding to all possible ASCII characters, plus 8&nbsp;*&nbsp;NUM_POSITION_SLOTS (see above) elements corresponding to matches. The second most important tree is the <em>length</em> tree, which comprises 249 elements.</p>

		<p>Other trees, such as the aligned offset tree (comprising 8 elements), and the pre-trees (comprising 20 elements each), have a smaller role.</p>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#concepts">Concepts</a> </p>

		<h4 class="dtH1">
			<a id="rep_offsets"></a>Repeated Offsets</h4>

		<p>LZX extends the conventional LZ77 format in several ways, one of which is in the use of repeated offset codes. Three match offset codes, named the <em>repeated offset codes</em>, are reserved to indicate that the current match offset is the same as that of one of the three previous matches which is not itself a repeated offset.</p>

		<p>The three special offset codes are encoded as offset values 0, 1, and 2 (i.e. encoding an offset of 0 means "use the most recent non-repeated match offset", an offset of 1 means "use the second most recent non-repeated match offset", etc.). All remaining offset values are displaced by +3, as is shown in the table below, which prevents matches at offsets WINDOW_SIZE, WINDOW_SIZE-1, and WINDOW_SIZE-2.</p>

		<p class="label"><strong>Correlation Between Encoded Offset and Real Offset</strong></p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Encoded Offset</th>
						<th scope="col">Real Offset</th>
					</tr>

					<tr>
						<td data-th="Encoded Offset">0</td>
						<td data-th="Real Offset">Most recent non-repeated match offset</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">1</td>
						<td data-th="Real Offset">Second most recent non-repeated match offset</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">2</td>
						<td data-th="Real Offset">Third most recent non-repeated match offset</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">3</td>
						<td data-th="Real Offset">1 (closest allowable)</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">4</td>
						<td data-th="Real Offset">2</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">5</td>
						<td data-th="Real Offset">3</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">6</td>
						<td data-th="Real Offset">4</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">7</td>
						<td data-th="Real Offset">5</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">8</td>
						<td data-th="Real Offset">6</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">500</td>
						<td data-th="Real Offset">498</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">x+2</td>
						<td data-th="Real Offset">x</td>
					</tr>

					<tr>
						<td data-th="Encoded Offset">WINDOW_SIZE-1
							<p><em>(maximum possible)</em></p>
						</td>
						<td data-th="Real Offset">WIDOW_SIZE-3</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>The three most recent non-repeated match offsets are kept in a list, the behavior of which explained below:</p>

		<blockquote class="dtBlock">
			Let R0 be defined as the most recent non-repeated offset</blockquote>

		<blockquote class="dtBlock">
			Let R1 be defined as the second most recent non-repeated offset</blockquote>

		<blockquote class="dtBlock">
			Let R2 be defined as the third most recent non-repeated offset</blockquote>

		<p>The list is managed similarly to an LRU (least recently used) queue, with the exception of the cases when R1 or R2 is output. In these cases, which are fairly uncommon, R1 or R2 is simply swapped with R0, which requires fewer operations than would an LRU queue. The compression penalty from doing so is essentially zero and it removes a small computational overhead from the decoder.</p>

		<p>The initial state of R0, R1, R2 is (1, 1, 1).</p>

		<p class="label"><strong>Management of the Repeated Offsets List</strong></p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Match Offset <em>X</em> where... </th>
						<th scope="col">Operation</th>
					</tr>

					<tr>
						<td data-th="Match Offset X where... ">X ≠ R0 and X ≠ R1 and X ≠ R2 </td>
						<td data-th="Operation">R2 ← R1
							<p>R1 ← R0</p>

							<p>R0 ← X </p>
						</td>
					</tr>

					<tr>
						<td data-th="Match Offset X where... ">X = R0</td>
						<td data-th="Operation">None</td>
					</tr>

					<tr>
						<td data-th="Match Offset X where... ">X = R1</td>
						<td data-th="Operation">Swap R0 ⇔ R1 </td>
					</tr>

					<tr>
						<td data-th="Match Offset X where... ">X = R2</td>
						<td data-th="Operation">Swap R0 ⇔ R2 </td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#concepts">Concepts</a> </p>

		<h4 class="dtH1">
			<a id="const"></a>Constants</h4>

		<p>The following named constants are used frequently in this document:</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Constant</th>
						<th scope="col">Description</th>
						<th scope="col">Value</th>
					</tr>

					<tr>
						<td data-th="Constant">MIN_MATCH</td>
						<td data-th="Description">Smallest allowable match length</td>
						<td data-th="Value">2</td>
					</tr>

					<tr>
						<td data-th="Constant">MAX_MATCH</td>
						<td data-th="Description">Largest allowable match length</td>
						<td data-th="Value">257</td>
					</tr>

					<tr>
						<td data-th="Constant">NUM_CHARS</td>
						<td data-th="Description">Number of uncompressed character types</td>
						<td data-th="Value">256</td>
					</tr>

					<tr>
						<td data-th="Constant">WINDOW_SIZE</td>
						<td data-th="Description">Window size</td>
						<td data-th="Value">Varies</td>
					</tr>

					<tr>
						<td data-th="Constant">NUM_POSITION_SLOTS</td>
						<td data-th="Description">Number of window subdivisions</td>
						<td data-th="Value">Dependent upon WINDOW_SIZE</td>
					</tr>

					<tr>
						<td data-th="Constant">MAIN_TREE_ELEMENTS</td>
						<td data-th="Description">Number of elements in main tree</td>
						<td data-th="Value">NUM_CHARS&nbsp;+&nbsp;NUM_POSITION_SLOTS*8</td>
					</tr>

					<tr>
						<td data-th="Constant">NUM_SECONDARY_LENGTHS</td>
						<td data-th="Description">Number of elements in length tree</td>
						<td data-th="Value">249</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#concepts">Concepts</a> </p>

		<h3 class="dtH1">
			<a id="lzx_form"></a>LZX Compressed Data Format</h3>

		<p>LZX compressed data consists of a header indicating the file translation size (which is described later), followed by a sequence of compressed blocks. A stream of uncompressed input may be output as multiple compressed LZX blocks to improve compression, since each compressed block contains its own statistical tree structures.</p>

		<p class="fig"><img id="lzx" alt="Bb417343.lzx(en-us,MSDN.10).gif" src="https://i-msdn.sec.s-msft.com/dynimg/IC100153.gif" title="Bb417343.lzx(en-us,MSDN.10).gif" xmlns=""></p>

		<h4 class="dtH1">This section includes:</h4>

		<blockquote class="dtBlock">
			<a href="#cab_blk">Cabinet Block Size</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#head_struct">Header Structure</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#enc_preproc">Encoder Preprocessing</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#block_struct">Block Structure</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#uncomp_block_frmt">Uncompressed Block Format</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#vbtm_block">Verbatim Block</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#algn_off_block">Aligned Offset Block</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#tree_p_tree">Encoding the Trees and Pre-Trees</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#com_lit">Compressed Literals</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#match_off">Match Offset &amp;#8658; Formatted Offset</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#form_off">Formatted Offset &amp;#8658; Position Slot, Position Footer</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#pos_foot">Position Footer &amp;#8658; Verbatim Bits, Aligned Offset Bits</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#match_length">Match Length &amp;#8658; Length Header, Length Footer</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#length_head">Length Header, Position Slot &amp;#8658; Length/Position Header</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#enc_match">Encoding a Match</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#dec_match">Decoding a Match or an Uncompressed Character</a> </blockquote>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> </p>

		<h4 class="dtH1">
			<a id="cab_blk"></a>Cab Block Size</h4>

		<p>The cabinet file format requires that for any particular CFDATA block, the indicated number of compressed input bytes must represent exactly the indicated number of uncompressed output bytes. Furthermore, each CFDATA block must represent 32768 uncompressed bytes, with the exception of the last CFDATA block in a folder, which may represent less than 32768 uncompressed bytes.</p>

		<p>The LZX block size is independent of the CFDATA block size; an LZX block can represent 200,000 uncompressed bytes, for example. In order to ensure that an exact number of input bytes represent an exact number of output bytes, after each 32768<span class="sup">th</span> uncompressed byte is represented, the output bit buffer is byte aligned on a 16-bit boundary by outputting 0-15 zero bits. The bit buffer is flushed in an identical manner after the final CFDATA block in a folder. Furthermore, the compressor may not emit any matches that span a 32768-byte boundary in the input (for example, at position 65528 in the input, the compressor cannot emit a match with a length of 50; the maximum allowable match length at this point would be 6).</p>

		<p>One additional constraint is that, for any given CFDATA block, the compressed size of a CFDATA block may not occupy more than 32768+6144 bytes (i.e. 32K of uncompressed input may not grow by more than 6K when compressed).</p>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h4 class="dtH1">
			<a id="head_struct"></a>Header Structure</h4>

		<p>The header consists of either a zero bit indicating no encoder preprocessing, or a one bit followed by a <em>file translation size</em>, a value which is used in encoder preprocessing.</p>
		<div class="tablediv">
			<table class="dtTABLE" summary="table">

				<tbody>
					<tr>
						<td>0</td>
						<td colspan="2">&nbsp;</td>
					</tr>

					<tr>
						<td>1</td>
						<td>Most significant 16 bits of file translation size</td>
						<td>Least significant 16 bits of file translation size</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h4 class="dtH1">
			<a id="enc_preproc"></a>Encoder preprocessing</h4>

		<p>The encoder may optionally perform a preprocessing stage on all CFDATA input blocks (size &lt;= 32K) which improves compression on 32-bit Intel 80x86 code. The translation is performed before the data is passed to the compressor, and therefore an appropriate reverse translation must be performed on the output of the decompressor. A bit indicating whether preprocessing was used is stored in the compression header (see above).</p>

		<p>The preprocessing stage translates 80x86 CALL instructions, which begin with the E8 (hex) opcode, to use absolute offsets instead of relative offsets.</p>

		<p>Preprocessing is disabled after the 32768<span class="sup">th</span> CAB input frame in a folder (where a CAB input frame is 32768 bytes) in order to avoid signed/unsigned arithmetic complexity. This change can obviously occur only when a folder represents at least 1 gigabyte of uncompressed data.</p>

		<p class="label"><strong>CALL Byte Sequence (E8 followed by 32 bit offset)</strong></p>

		<pre class="code">E8 r<span class="sub">0</span> r<span class="sub">1</span> r<span class="sub">2</span> r<span class="sub">3</span>
</pre>

		<p class="label"><strong>Performing the Relative-to-Absolute Conversion</strong></p>

		<pre class="code">relative_offset ← r<span class="sub">0</span> + r<span class="sub">1</span>*2<span class="sup">8</span> + r<span class="sub">2</span>*2<span class="sup">16</span> + r<span class="sub">3</span>*2<span class="sup">24</span> 
new_value ← conversion_function(current_location, relative_offset)
a<span class="sub">0</span> ← bits 0-7 of new_value
a<span class="sub">1</span> ← bits 8-15 of new_value
a<span class="sub">2</span> ← bits 16-23 of new_value
a<span class="sub">3</span> ← bits 24-31 of new_value
</pre>

		<p class="label"><strong>Translated CALL Byte Sequence</strong></p>

		<pre class="code">E8 a<span class="sub">0</span> a<span class="sub">1</span> a<span class="sub">2</span> a<span class="sub">3</span>
</pre>

		<p>The diagram below illustrates the relative-to-absolute conversion function, where <em>curpos </em>is the current offset within all uncompressed data seen in the current cabinet folder, and <em>file_size</em> is the file translation size from the compression header (<em>file_size</em> is unrelated to the size of the actual file being decompressed).</p>

		<p>The translation is performed "in place" on the input data without using extra codes to indicate whether a translation occurred (i.e. there is a direct mapping from a 32-bit value to a 32-bit value), therefore there is a one-to-one correlation between pre- and post- translated values.</p>

		<p class="label"><strong>Offset Translation Diagram</strong></p>

		<p class="fig"><img id="offset_trans" alt="Bb417343.offset_trans(en-us,MSDN.10).gif" src="https://i-msdn.sec.s-msft.com/dynimg/IC107532.gif" title="Bb417343.offset_trans(en-us,MSDN.10).gif" xmlns=""></p>

		<p>From the diagram one can see that values in the range of <em>0x80000000 (-2</em><span class="sup">31</span><em>) </em>to<em> -curpos</em>, and <em>file_size </em>to<em> 0x7FFFFFFFF (+2</em><span class="sup">31</span><em>)</em> are left unchanged. The translation algorithm operates as follows on an input block of size <em>input_size</em>, where 0 &lt;= <em>input_size</em> &lt;= 32768. No translation may be performed on the last 6 bytes of the input block.</p>

		<pre class="code">if (input_size &lt; 6)
return         /* don't perform translation if &lt; 6 input bytes */

for (i = 0; i &lt; input_size; i++)

   if (input_data[i] == 0xE8)
	  if (i &gt;= input_size-6)
   break;
	  endif
	  
	  ... perform translation illustrated above …
   endif
</pre>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h4 class="dtH1">
			<a id="block_struct"></a>Block Structure</h4>

		<p>Each block of compressed data begins with a 3 bit header describing the block type, followed by the block itself. The allowable block types are:</p>
		<div class="tablediv">
			<table class="dtTABLE" summary="table">

				<tbody>
					<tr>
						<td>0</td>
						<td>Undefined</td>
					</tr>

					<tr>
						<td>1</td>
						<td>Verbatim block</td>
					</tr>

					<tr>
						<td>2</td>
						<td>Aligned offset block</td>
					</tr>

					<tr>
						<td>3</td>
						<td>Uncompressed block</td>
					</tr>

					<tr>
						<td>4-7</td>
						<td>Undefined</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h4 class="dtH1">
			<a id="uncomp_block_frmt"></a>Uncompressed Block Format</h4>

		<p>An uncompressed block begins with 1 to 16 bits of zero padding to align the bit buffer on a 16-bit boundary. At this point, the bitstream ends, and a <em>bytestream</em> begins. The data that follows is encoded as bytes for performance. Following the zero padding, new values for R<span class="sub">0</span>, R<span class="sub">1</span>, and R<span class="sub">2</span> are output in little-endian form, followed by the uncompressed data bytes themselves.</p>
		<div class="tablediv">
			<table class="dtTABLE" summary="table">

				<tbody>
					<tr>
						<td>1-16 bits </td>
						<td>4 bytes</td>
						<td>4 bytes</td>
						<td>4 bytes</td>
						<td><em>n</em> bytes</td>
					</tr>

					<tr>
						<td>zero padding</td>
						<td>R0
							<p>(LSB first)</p>
						</td>
						<td>R1
							<p>(LSB first)</p>
						</td>
						<td>R2
							<p>(LSB first)</p>
						</td>
						<td>Uncompressed data</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h4 class="dtH1">
			<a id="vbtm_block"></a>Verbatim Block</h4>

		<p>A verbatim block consists of the following:</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Entry</th>
						<th scope="col">Comments</th>
						<th scope="col">Size</th>
					</tr>

					<tr>
						<td data-th="Entry">Number of uncompressed bytes accounted for in this block</td>
						<td data-th="Comments">Range of 1...2<span class="sup">24</span> </td>
						<td data-th="Size">24 bits</td>
					</tr>

					<tr>
						<td data-th="Entry">Pre-tree for first 256 elements of main tree</td>
						<td data-th="Comments">20 elements, 4 bits each</td>
						<td data-th="Size">80 bits</td>
					</tr>

					<tr>
						<td data-th="Entry">Path lengths of first 256 elements of main tree</td>
						<td data-th="Comments">Encoded using pre-tree</td>
						<td data-th="Size">Variable</td>
					</tr>

					<tr>
						<td data-th="Entry">Pre-tree for remainder of main tree</td>
						<td data-th="Comments">20 elements, 4 bits each</td>
						<td data-th="Size">80 bits</td>
					</tr>

					<tr>
						<td data-th="Entry">Path lengths of remaining elements of main tree</td>
						<td data-th="Comments">Encoded using pre-tree</td>
						<td data-th="Size">Variable</td>
					</tr>

					<tr>
						<td data-th="Entry">Pre-tree for length tree</td>
						<td data-th="Comments">20 elements, 4 bits each</td>
						<td data-th="Size">80 bits</td>
					</tr>

					<tr>
						<td data-th="Entry">Path lengths of elements in length tree</td>
						<td data-th="Comments">Encoded using pre-tree</td>
						<td data-th="Size">Variable</td>
					</tr>

					<tr>
						<td data-th="Entry">Compressed literals</td>
						<td data-th="Comments">Described later</td>
						<td data-th="Size">Variable</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h4 class="dtH1">
			<a id="algn_off_block"></a>Aligned Offset Block</h4>

		<p>An aligned offset block consists of the following:</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Entry</th>
						<th scope="col">Comments</th>
						<th scope="col">Size</th>
					</tr>

					<tr>
						<td data-th="Entry">Number of uncompressed bytes accounted for in this block</td>
						<td data-th="Comments">Range of 1...2<span class="sup">24</span> </td>
						<td data-th="Size">24 bits</td>
					</tr>

					<tr>
						<td data-th="Entry">Pre-tree for first 256 elements of main tree</td>
						<td data-th="Comments">20 elements, 4 bits each</td>
						<td data-th="Size">80 bits</td>
					</tr>

					<tr>
						<td data-th="Entry">Path lengths of first 256 elements of main tree</td>
						<td data-th="Comments">Encoded using pre-tree</td>
						<td data-th="Size">Variable</td>
					</tr>

					<tr>
						<td data-th="Entry">Pre-tree for remainder of main tree</td>
						<td data-th="Comments">20 elements, 4 bits each</td>
						<td data-th="Size">80 bits</td>
					</tr>

					<tr>
						<td data-th="Entry">Path lengths of remaining elements of main tree</td>
						<td data-th="Comments">Encoded using pre-tree</td>
						<td data-th="Size">Variable</td>
					</tr>

					<tr>
						<td data-th="Entry">Aligned offset tree</td>
						<td data-th="Comments">8 elements, 3 bits each</td>
						<td data-th="Size">24 bits</td>
					</tr>

					<tr>
						<td data-th="Entry">Compressed literals</td>
						<td data-th="Comments">Described later</td>
						<td data-th="Size">Variable</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>The aligned offset tree comprises only 8 elements, each of which is encoded as a 3 bit path length. Since the size of this tree is so small, no additional compression is performed on it.</p>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h4 class="dtH1">
			<a id="tree_p_tree"></a>Encoding the Trees and Pre-Trees</h4>

		<p>Since all trees used in LZX are created in the form of a canonical Huffman tree, the path length of each element in the tree is sufficient to reconstruct the original tree. The main tree and the length tree are each encoded using the method described below. However, the main tree is encoded in two components as if it were two separate trees, the first tree corresponding to the first 256 tree elements (uncompressed symbols), and the second tree corresponding to the remaining elements (matches).</p>

		<p>Since trees are output several times during compression of large amounts of data, LZX optimizes compression by encoding only the delta path lengths between the current and previous trees. In the case of the very first such tree, the delta is calculated against a tree in which all elements have a zero path length.</p>

		<p>Each tree element may have a path length from 0 to 16 (inclusive) where a zero path length indicates that the element has a zero frequency and is not present in the tree. Tree elements are output in sequential order starting with the first element. Elements may be encoded in one of two ways -if several consecutive elements have the same path length, then run length encoding is employed; otherwise the element is output by encoding the difference between the current path length and the previous path length of the tree, mod 17. These output methods are described below:</p>

		<p class="label"><strong>Tree Codes</strong></p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Code</th>
						<th scope="col">Operation</th>
					</tr>

					<tr>
						<td data-th="Code">0-16</td>
						<td data-th="Operation">Len[x] = (prev_len[x] + code) mod 17</td>
					</tr>

					<tr>
						<td data-th="Code">17</td>
						<td data-th="Operation">Zeroes = getbits(4)
							<p>Len[x] = 0 for next (4 + Zeroes) elements</p>
						</td>
					</tr>

					<tr>
						<td data-th="Code">18</td>
						<td data-th="Operation">Zeroes = getbits(5)
							<p>Len[x] = 0 for next (20 + Zeroes) elements</p>
						</td>
					</tr>

					<tr>
						<td data-th="Code">19</td>
						<td data-th="Operation">Same = getbits(1)
							<p>Decode new Code</p>

							<p>Value = (prev_len[x] + Code) mod 17</p>

							<p>Len[x] = Value for next (4 + Same) elements</p>
						</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Each of the 17 possible values of (<em>len[x] - prev_len[x]) mod 17</em>, plus three additional codes used for run-length encoding, are <em>not</em> output directly as 5 bit numbers, but are instead encoded via a Huffman tree called the <em>pre- tree</em>. The pre-tree is generated dynamically according to the frequencies of the 20 allowable tree codes. The structure of the pre-tree is encoded in a total of 80 bits by using 4 bits to output the path length of each of the 20 pre-tree elements. Once again, a zero path length indicates a zero frequency element.</p>

		<p class="label"><strong>Pre-Tree</strong></p>
		<div class="tablediv">
			<table class="dtTABLE" summary="table">

				<tbody>
					<tr>
						<td>Length of tree code 0</td>
						<td>4 bits</td>
					</tr>

					<tr>
						<td>Length of tree code 1</td>
						<td>4 bits</td>
					</tr>

					<tr>
						<td>Length of tree code 2</td>
						<td>4 bits</td>
					</tr>

					<tr>
						<td>...</td>
						<td>...</td>
					</tr>

					<tr>
						<td>Length of tree code 18</td>
						<td>4 bits</td>
					</tr>

					<tr>
						<td>Length of tree code 19</td>
						<td>4 bits</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>The "real" tree is then encoded using the pre-tree Huffman codes.</p>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h4 class="dtH1">
			<a id="com_lit"></a>Compressed Literals</h4>

		<p>The compressed literals that make up the bulk of either a verbatim block or an aligned offset block immediately follow the tree data (as shown in the diagram for each block type). These literals, which comprise matches and unmatched characters, will, when decompressed, correspond to exactly the number of uncompressed bytes indicated in the block header.</p>

		<p>The representation of an unmatched character in the output is simply the appropriate element 0…(NUM_CHARS-1) Huffman-encoded using the main tree.</p>

		<p>The representation of a match in the output involves several transformations, as shown in the following diagram. At the top of the diagram are the match length (MIN_MATCH…MAX_MATCH) and the match offset (0…WINDOW_SIZE-4). The match offset and match length are split into sub-components and encoded separately.</p>

		<p>As mentioned previously, in order to remain compatible with the cabinet file format, the compressor may not emit any matches that span a 32768-byte boundary in the input.</p>

		<p class="label"><strong>Diagram of Match Sub-Components</strong></p>

		<p class="fig"><img id="match_sub" alt="Bb417343.match_sub(en-us,MSDN.10).gif" src="https://i-msdn.sec.s-msft.com/dynimg/IC81501.gif" title="Bb417343.match_sub(en-us,MSDN.10).gif" xmlns=""></p>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h4 class="dtH1">
			<a id="match_off"></a>Match Offset ⇒ Formatted Offset</h4>

		<p>The match offset, range 1...(WINDOW_SIZE-4), is converted into a <em>formatted offset</em> by determining whether the offset can be encoded as a repeated offset, as shown below. It is acceptable to not encode a match as a repeated offset even if it is possible to do so.</p>

		<p class="label"><strong>Converting a Match Offset to a Formatted Offset</strong></p>

		<pre class="code">if offset == R0 then
   formatted offset ← 0
else if offset == R1 then
   formatted offset ← 1
else if offset == R2 then
   formatted offset ← 2
else
   formatted offset ← offset + 2
endif
</pre>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h3 class="dtH1">
			<a id="form_off"></a>Formatted Offset ⇒ Position Slot, Position Footer</h3>

		<p>The formatted offset is subdivided into a position slot and a position footer. The position slot defines the most significant bits of the formatted offset in the form of a base position as shown in the table on the following page. The position footer defines the remaining least significant bits of the formatted offset. As the table shows, the number of bits dedicated to the position footer grows as the formatted offset becomes larger, meaning that each position slot addresses a larger and larger range.</p>

		<p>The number of position slots available depends on the window size. The position slot table for the maximum window size of 2 megabytes, is shown in the table below.</p>

		<p class="label"><strong>Position Slot Table</strong></p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Position Slot Number</th>
						<th scope="col">Base Position</th>
						<th scope="col">Number of Position Footer Bits</th>
						<th scope="col">Range of Base Position and Position Footer</th>
					</tr>

					<tr>
						<td data-th="Position Slot Number">0</td>
						<td data-th="Base Position">0</td>
						<td data-th="Number of Position Footer Bits">0</td>
						<td data-th="Range of Base Position and Position Footer">0</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">1</td>
						<td data-th="Base Position">1</td>
						<td data-th="Number of Position Footer Bits">0</td>
						<td data-th="Range of Base Position and Position Footer">1</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">2</td>
						<td data-th="Base Position">2</td>
						<td data-th="Number of Position Footer Bits">0</td>
						<td data-th="Range of Base Position and Position Footer">2</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">3</td>
						<td data-th="Base Position">3</td>
						<td data-th="Number of Position Footer Bits">0</td>
						<td data-th="Range of Base Position and Position Footer">3</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">4</td>
						<td data-th="Base Position">4</td>
						<td data-th="Number of Position Footer Bits">1</td>
						<td data-th="Range of Base Position and Position Footer">4-5</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">5</td>
						<td data-th="Base Position">6</td>
						<td data-th="Number of Position Footer Bits">1</td>
						<td data-th="Range of Base Position and Position Footer">6-7</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">6</td>
						<td data-th="Base Position">8</td>
						<td data-th="Number of Position Footer Bits">2</td>
						<td data-th="Range of Base Position and Position Footer">8-11</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">7</td>
						<td data-th="Base Position">12</td>
						<td data-th="Number of Position Footer Bits">2</td>
						<td data-th="Range of Base Position and Position Footer">12-15</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">8</td>
						<td data-th="Base Position">16</td>
						<td data-th="Number of Position Footer Bits">3</td>
						<td data-th="Range of Base Position and Position Footer">16-23</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">9</td>
						<td data-th="Base Position">24</td>
						<td data-th="Number of Position Footer Bits">3</td>
						<td data-th="Range of Base Position and Position Footer">24-31</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">10</td>
						<td data-th="Base Position">32</td>
						<td data-th="Number of Position Footer Bits">4</td>
						<td data-th="Range of Base Position and Position Footer">32-47</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">11</td>
						<td data-th="Base Position">48</td>
						<td data-th="Number of Position Footer Bits">4</td>
						<td data-th="Range of Base Position and Position Footer">48-63</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">12</td>
						<td data-th="Base Position">64</td>
						<td data-th="Number of Position Footer Bits">5</td>
						<td data-th="Range of Base Position and Position Footer">64-95</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">13</td>
						<td data-th="Base Position">96</td>
						<td data-th="Number of Position Footer Bits">5</td>
						<td data-th="Range of Base Position and Position Footer">96-127</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">14</td>
						<td data-th="Base Position">128</td>
						<td data-th="Number of Position Footer Bits">6</td>
						<td data-th="Range of Base Position and Position Footer">128-191</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">15</td>
						<td data-th="Base Position">192</td>
						<td data-th="Number of Position Footer Bits">6</td>
						<td data-th="Range of Base Position and Position Footer">192-255</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">16</td>
						<td data-th="Base Position">256</td>
						<td data-th="Number of Position Footer Bits">7</td>
						<td data-th="Range of Base Position and Position Footer">256-383</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">17</td>
						<td data-th="Base Position">384</td>
						<td data-th="Number of Position Footer Bits">7</td>
						<td data-th="Range of Base Position and Position Footer">384-511</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">18</td>
						<td data-th="Base Position">512</td>
						<td data-th="Number of Position Footer Bits">8</td>
						<td data-th="Range of Base Position and Position Footer">512-767</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">19</td>
						<td data-th="Base Position">768</td>
						<td data-th="Number of Position Footer Bits">8</td>
						<td data-th="Range of Base Position and Position Footer">768-1023</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">20</td>
						<td data-th="Base Position">1024</td>
						<td data-th="Number of Position Footer Bits">9</td>
						<td data-th="Range of Base Position and Position Footer">1024-1535</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">21</td>
						<td data-th="Base Position">1536</td>
						<td data-th="Number of Position Footer Bits">9</td>
						<td data-th="Range of Base Position and Position Footer">1536-2047</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">22</td>
						<td data-th="Base Position">2048</td>
						<td data-th="Number of Position Footer Bits">10</td>
						<td data-th="Range of Base Position and Position Footer">2048-3071</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">23</td>
						<td data-th="Base Position">3072</td>
						<td data-th="Number of Position Footer Bits">10</td>
						<td data-th="Range of Base Position and Position Footer">3072-4095</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">24</td>
						<td data-th="Base Position">4096</td>
						<td data-th="Number of Position Footer Bits">11</td>
						<td data-th="Range of Base Position and Position Footer">4096-6143</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">25</td>
						<td data-th="Base Position">6144</td>
						<td data-th="Number of Position Footer Bits">11</td>
						<td data-th="Range of Base Position and Position Footer">6144-8191</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">26</td>
						<td data-th="Base Position">8192</td>
						<td data-th="Number of Position Footer Bits">12</td>
						<td data-th="Range of Base Position and Position Footer">8192-12287</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">27</td>
						<td data-th="Base Position">12288</td>
						<td data-th="Number of Position Footer Bits">12</td>
						<td data-th="Range of Base Position and Position Footer">12288-16383</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">28</td>
						<td data-th="Base Position">16384</td>
						<td data-th="Number of Position Footer Bits">13</td>
						<td data-th="Range of Base Position and Position Footer">16384-24575</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">29</td>
						<td data-th="Base Position">24576</td>
						<td data-th="Number of Position Footer Bits">13</td>
						<td data-th="Range of Base Position and Position Footer">24576-32767</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">30</td>
						<td data-th="Base Position">32768</td>
						<td data-th="Number of Position Footer Bits">14</td>
						<td data-th="Range of Base Position and Position Footer">32768-49151</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">31</td>
						<td data-th="Base Position">49152</td>
						<td data-th="Number of Position Footer Bits">14</td>
						<td data-th="Range of Base Position and Position Footer">49152-65535</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">32</td>
						<td data-th="Base Position">65536</td>
						<td data-th="Number of Position Footer Bits">15</td>
						<td data-th="Range of Base Position and Position Footer">65536-98303</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">33</td>
						<td data-th="Base Position">98304</td>
						<td data-th="Number of Position Footer Bits">15</td>
						<td data-th="Range of Base Position and Position Footer">98304-131071</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">34</td>
						<td data-th="Base Position">131072</td>
						<td data-th="Number of Position Footer Bits">16</td>
						<td data-th="Range of Base Position and Position Footer">131072-196607</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">35</td>
						<td data-th="Base Position">196608</td>
						<td data-th="Number of Position Footer Bits">16</td>
						<td data-th="Range of Base Position and Position Footer">196608-262143</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">36</td>
						<td data-th="Base Position">262144</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">262144-393215</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">37</td>
						<td data-th="Base Position">393216</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">393216-524287</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">38</td>
						<td data-th="Base Position">524288</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">524288-655359</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">39</td>
						<td data-th="Base Position">655360</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">655360-786431</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">40</td>
						<td data-th="Base Position">786432</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">786432-917503</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">41</td>
						<td data-th="Base Position">917504</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">917504-1048575</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">42</td>
						<td data-th="Base Position">1048576</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">1048576-1179647</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">43</td>
						<td data-th="Base Position">1179648</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">1179648-1310719</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">44</td>
						<td data-th="Base Position">1310720</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">1310720-1441791</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">45</td>
						<td data-th="Base Position">1441792</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">1441792-1572863</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">46</td>
						<td data-th="Base Position">1572864</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">1572864-1703935</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">47</td>
						<td data-th="Base Position">1703936</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">1703936-1835007</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">48</td>
						<td data-th="Base Position">1835008</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">1835008-1966079</td>
					</tr>

					<tr>
						<td data-th="Position Slot Number">49</td>
						<td data-th="Base Position">1966080</td>
						<td data-th="Number of Position Footer Bits">17</td>
						<td data-th="Range of Base Position and Position Footer">1966080-2097151</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>In order to determine the position footer, it is first necessary to determine the position slot. Then, a simple lookup can be performed on the position slot to determine the number of bits, B, in the position footer. The B least significant bits of the formatted offset are the position footer. Pseudocode for obtaining the position slot and position footer are shown below, as is the lookup array (named <em>extra_bits</em>).</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">n<br> (position slot)</th>
						<th scope="col">extra_bits[n]<br> (number of position footer bits)</th>
					</tr>

					<tr>
						<td data-th="n
(position slot)">0</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">0</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">1</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">0</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">2</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">0</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">3</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">0</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">4</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">1</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">5</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">1</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">6</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">2</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">7</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">2</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">8</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">3</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">9</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">3</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">10</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">4</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">11</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">4</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">12</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">5</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">13</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">5</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">14</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">6</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">15</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">6</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">16</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">7</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">17</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">7</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">18</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">8</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">19</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">8</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">20</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">9</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">21</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">9</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">22</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">10</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">23</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">10</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">24</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">11</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">25</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">11</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">26</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">12</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">27</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">12</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">28</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">13</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">29</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">13</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">30</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">14</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">31</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">14</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">32</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">15</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">33</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">15</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">34</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">16</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">35</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">16</td>
					</tr>

					<tr>
						<td data-th="n
(position slot)">36-49</td>
							<td data-th="extra_bits[n]
(number of position footer bits)">17</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p class="label"><strong>Converting the Position Slot and Position Footer</strong></p>

		<pre class="code">position_slot ← calculate_position_slot(formatted_offset)
position_footer_bits ← extra_bits[ position_slot ]
if position_footer_bits &gt; 0
	  position_footer ← formatted_offset &amp; ((2^position_footer_bits)-1)
else
	  position_footer ← null
</pre>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h3 class="dtH1">
			<a id="pos_foot"></a>Position Footer ⇒ Verbatim Bits, Aligned Offset Bits</h3>

		<p>The position footer may be further subdivided into verbatim bits and aligned offset bits if the current block uses aligned offsets. If the current block is not an aligned offset block then there are no aligned offset bits, and the verbatim bits are the position footer.</p>

		<p>If aligned offsets are used, then the lower 3 bits of the position footer are the aligned offset bits, while the remaining portion of the position footer are the verbatim bits. In the case where there are less than 3 bits in the position footer (i.e. formatted offset is &lt;= 15) it is not possible to take the "lower 3 bits of the position footer" and therefore there are no aligned offset bits, and the verbatim bits and the position footer are the same.</p>

		<p class="label"><strong>Pseudocode for Splitting Position Footer into Verbatim Bits and Aligned Offset</strong></p>

		<pre class="code">if block_type = aligned_offset_block then
   if formatted_offset &lt;= 15 then
	  verbatim_bits ← position_footer
	  aligned_offset ← null
   else
	  aligned_offset ← position_footer
	  verbatim_bits ← position_footer &gt;&gt; 3
   endif
else
   verbatim_bits ← position_footer
   aligned_offset ← null
endif 
</pre>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h3 class="dtH1">
			<a id="match_length"></a>Match Length ⇒ Length Header, Length Footer</h3>

		<p>The match length is converted into a length header and a length footer. The length header may have one of eight possible values, from 0...7 (inclusive), indicating a match of length 2, 3, 4, 5, 6, 7, 8, or a length greater than 8. If the match length is 8 or less, then there is no length footer. Otherwise the value of the length footer is equal to the match length minus 9.</p>

		<p class="label"><strong>Pseudocode for Obtaining the Length Header and Footer</strong></p>

		<pre class="code">if match_length &lt;= 8
   length_header ← match_length-2
   length_footer ← null
else
   length_header ← 7
   length_footer ← match_length-9
endif
</pre>

		<p class="label"><strong>Example Conversions of Some Match Lengths to Header and Footer Values</strong></p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Match length</th>
						<th scope="col">Length header</th>
						<th scope="col">Length footer value</th>
					</tr>

					<tr>
						<td data-th="Match length">2 (MIN_MATCH)</td>
						<td data-th="Length header">0</td>
						<td data-th="Length footer value">None</td>
					</tr>

					<tr>
						<td data-th="Match length">3</td>
						<td data-th="Length header">1</td>
						<td data-th="Length footer value">None</td>
					</tr>

					<tr>
						<td data-th="Match length">4</td>
						<td data-th="Length header">2</td>
						<td data-th="Length footer value">None</td>
					</tr>

					<tr>
						<td data-th="Match length">5</td>
						<td data-th="Length header">3</td>
						<td data-th="Length footer value">None</td>
					</tr>

					<tr>
						<td data-th="Match length">6</td>
						<td data-th="Length header">4</td>
						<td data-th="Length footer value">None</td>
					</tr>

					<tr>
						<td data-th="Match length">7</td>
						<td data-th="Length header">5</td>
						<td data-th="Length footer value">None</td>
					</tr>

					<tr>
						<td data-th="Match length">8</td>
						<td data-th="Length header">6</td>
						<td data-th="Length footer value">None</td>
					</tr>

					<tr>
						<td data-th="Match length">9</td>
						<td data-th="Length header">7</td>
						<td data-th="Length footer value">0</td>
					</tr>

					<tr>
						<td data-th="Match length">10</td>
						<td data-th="Length header">7</td>
						<td data-th="Length footer value">1</td>
					</tr>

					<tr>
						<td data-th="Match length">50</td>
						<td data-th="Length header">7</td>
						<td data-th="Length footer value">41</td>
					</tr>

					<tr>
						<td data-th="Match length">257 (MAX_MATCH)</td>
						<td data-th="Length header">7</td>
						<td data-th="Length footer value">248</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h3 class="dtH1">
			<a id="length_head"></a>Length Header, Position Slot ⇒ Length/Position Header</h3>

		<p>The Length/Position header is the stage which correlates the match position with the match length (using only the most significant bits), and is created by combining the length header and the position slot as shown below:</p>

		<pre class="code">len_pos_header ← (position_slot &lt; &lt; 3) + length_header
</pre>

		<p>This operation creates a unique value for every combination of match length 2, 3, 4, 5, 6, 7, 8 with every possible position slot. The remaining match lengths greater than 8 are all lumped together, and as a group are correlated with every possible position slot.</p>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h3 class="dtH1">
			<a id="enc_match"></a>Encoding a Match</h3>

		<p>The match is finally output in up to four components, as follows:

		</p>
		<ol>
			<li>Output element (len_pos_header + NUM_CHARS) from the main tree</li>

			<li>If length_footer != null, then output element length_footer from the length tree</li>

			<li>If verbatim_bits != null, then output verbatim_bits</li>

			<li>If aligned_offset_bits != null, then output element aligned_offset from the aligned offset tree</li>
		</ol>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a> </p>

		<h3 class="dtH1">
			<a id="dec_match"></a>Decoding a Match or an Uncompressed Character</h3>

		<p>Decoding is performed by first decoding an element using the main tree and then, if the item is a match, determining which additional components are necessary to reconstruct the match. Pseudocode for decoding a match or an uncompressed character is shown below:</p>

		<pre class="code">main_element = main_tree.decode_element()

if (main_element &lt; NUM_CHARS) /* is an uncompressed character */

   window[ curpos ] ← (byte) main_element
   curpos ← curpos + 1

else /* is a match */

	  length_header ← (main_element – NUM_CHARS) &amp; NUM_PRIMARY_LENGTHS

	  if (length_header == NUM_PRIMARY_LENGTHS) 
			match_length ← length_tree.decode_element() + NUM_PRIMARY_LENGTHS + MIN_MATCH
	  else
			match_length ← length_header + MIN_MATCH /* no length footer */
	  endif

	  position_slot ← (main_element – NUM_CHARS) &gt;&gt; 3

	  /* check for repeated offsets (positions 0,1,2) */
	  if (position_slot == 0)
			match_offset ← R0
	  else if (position_slot == 1)
			match_offset ← R1
			swap(R0 ⇔ R1)
	  else if (position_slot == 2)
			match_offset ← R2
			swap(R0 ⇔ R2)
	  else /* not a repeated offset */
			extra ← extra_bits[ position_slot ] 

			if (block_type == aligned_offset_block)
				  if (extra &gt; 3) /* this means there are some aligned bits */
						verbatim_bits ← (readbits(extra-3)) &lt;&lt; 3
						aligned_bits  ← aligned_offset_tree.decode_element();
				  else if (extra &gt; 0) /* just some verbatim bits */
						verbatim_bits ← readbits(extra)
						aligned_bits  ← 0
				  else /* no verbatim bits */
						verbatim_bits ← 0
						aligned_bits  ← 0
			endif

			formatted_offset ← base_position[ position_slot ] + verbatim_bits + aligned_bits
	  else /* block_type == verbatim_block */
			if (extra &gt; 0) /* if there are any extra bits */
				  verbatim_bits ← readbits(extra)
			else
				  verbatim_bits ← 0
			endif

			formatted_offset ← base_position[ position_slot ] + verbatim_bits
	  endif

	  match_offset ← formatted_offset – 2

	  /* update repeated offset LRU queue */
	  R2 ← R1
	  R1 ← R0
	  R0 ← match_offset

	  /* copy match data */
	  for (i = 0; i &lt; match_length; i++)
			window[curpos + i] ← window[curpos + i – match_offset]

	  curpos ? curpos + match_length
endif
</pre>

		<p>Back to: <a href="#lzxdatacompressionformat">LZX Data Compression Format</a> &gt; <a href="#lzx_form">LZX Format</a></p>

		<h1 class="dtH1">
			<a id="microsoftmakecabusersguide"></a>Microsoft MakeCAB User's Guide</h1>

		<p>Copyright © 1997 Microsoft Corporation. All rights reserved.</p>

		<h4 class="dtH1">Topics in this Section</h4>

		<p><a href="#over">Overview</a> </p>

		<blockquote class="dtBlock">
			<a href="#case1">Case 1: MakeCAB for Setup Programs</a> </blockquote>

		<blockquote class="dtBlock">
			&nbsp;&nbsp;&nbsp;<a href="#c1_chars">Characteristics of a Setup Program</a> </blockquote>

		<blockquote class="dtBlock">
			&nbsp;&nbsp;&nbsp;<a href="#c1_app">MakeCAB Application</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#case2">Case 2: MakeCAB for a 200MB Source Code Archive</a> </blockquote>

		<blockquote class="dtBlock">
			&nbsp;&nbsp;&nbsp;<a href="#c2_chars">Characteristics of a Source Code Archive</a> </blockquote>

		<blockquote class="dtBlock">
			&nbsp;&nbsp;&nbsp;<a href="#c2_app">MakeCAB Application</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#case3">Case 3: Self-extracting Cabinet File(s)</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#deliverables">MakeCAB Deliverables</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#makecabgoals">MakeCAB Goals</a> </blockquote>

		<p><a href="#makecaboptimizingandtuning">MakeCAB Optimizing and Tuning</a> </p>

		<blockquote class="dtBlock">
			<a href="#save">Saving Diskettes</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#tuning">Tuning Access Time vs. Compression Ratio</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#ddfs">Piecemeal DDFs for Localization and Different Disk Sizes</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#time">Creation Time</a> </blockquote>

		<p><a href="#concepts">MakeCAB Concepts</a> </p>

		<blockquote class="dtBlock">
			<a href="#decoupling">Decoupling File Layout and INF Layout</a> </blockquote>

		<p><a href="#makecab_exe">MAKECAB.EXE</a> </p>

		<blockquote class="dtBlock">
			<a href="#syntax">MAKECAB.EXE Syntax</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#com">Command Summary</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#var">Variable Summary</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#semantics">InfDisk/Cabinet/FileLineFormat Syntax and Semantics</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#inf">INF Parameters</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#com_details">Command Details</a> </blockquote>

		<blockquote class="dtBlock">
			<a href="#var_details">Variable Details</a> </blockquote>

		<p><a href="#extract_exe">EXTRACT.EXE</a> </p>

		<h3 class="dtH1">
			<a id="over"></a>Overview</h3>

		<p>MakeCAB is a lossless data compression tool that can be used for a wide variety of purposes. Although it was originally designed for use by setup programs, it can also be used in almost any situation where lossless data compression is required.</p>

		<p>MakeCAB has three key features: 1) storing multiple files in a single <em>cabinet ("CAB") </em>file, 2) performing compression <strong>across</strong> file boundaries, and 3) permitting files to span cabinets. While existing products such as PKZIP, LHARC, and ARJ, support some of these features, combining all three does not appear to be common practice. MakeCAB also supports self-extracting archives, by simply concatenating a cabinet file to EXTRACT.EXE.</p>

		<p>Depending upon the number of files to be compressed, and the access patterns expected (sequential or random access; whether most of the files will be requested at once or only a small portion of them), MakeCAB can be instructed to build cabinet files in different ways. One key concept in MakeCAB is the <em>folder</em>. A <em>folder </em>is a collection of one or more files which are compressed together, as a single entity.</p>

		<p>The cabinet file format is capable of supporting multiple forms of compression. At this time, MSZIP and LZX are the compression formats supported by Microsoft. Other compression formats are possible in the future.</p>

		<p>The following sections provide case studies of several <em>possible</em> ways that MakeCAB might be used. These are only provided to stimulate your imagination -- they are not the only ways in which MakeCAB can be used!</p>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> </p>

		<h4 class="dtH1">
			<a id="case1"></a>Case 1: MakeCAB for Setup Programs</h4>

		<p>Since MakeCAB was designed with setup programs in mind, it has a great deal of power and flexibility to tradeoff compressed size against speed of random access to files. The primary impact of MakeCAB is to minimize the number of diskettes required to distribute a product, thereby minimizing the Cost of Goods Sold (COGS).</p>

		<p>In order for MakeCAB to build the disk images for a product, a <em>directive file</em>, or DDF, which specifies the list of files in a product, and any constraints on which disks certain files should be located, must be created. The same <em> </em>directive file can even be used for all the various localized versions of a product, since directive files support parameterization.</p>

		<p><strong>This section includes:</strong></p>

		<p><a href="#c1_chars">Characteristics of a Setup Program</a> </p>

		<p><a href="#c1_app">MakeCAB Application</a> </p>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#over">Overview</a> </p>

		<h4 class="dtH1">
			<a id="c1_chars"></a>Characteristics of a Setup Program</h4>

		<ol>
			<li>Minimizing disk count is very important, since it saves money in production costs.</li>

			<li>Files are accessed sequentially.</li>

			<li>Most files are accessed.</li>
		</ol>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#over">Overview</a> &gt; <a href="#case1">Case 1: MakeCAB for Setup Programs</a> </p>

		<h4 class="dtH1">
			<a id="c1_app"></a>MakeCAB Application</h4>

		<p>The distribution disks for a typical application product produced by MakeCAB might look similar to the following:<br>
		</p>

		<p class="label"><strong>Distribution disk layout</strong></p>

		<p class="fig"><img id="c1_app" alt="Bb417343.c1_app(en-us,MSDN.10).gif" src="https://i-msdn.sec.s-msft.com/dynimg/IC118498.gif" title="Bb417343.c1_app(en-us,MSDN.10).gif" xmlns=""></p>

		<p>SETUP.EXE is the setup program, and SETUP.INF is a file generated by MakeCAB which guides the operation of the setup program (which files are needed for which options, and on which disk and in which cabinet file a file is contained). All of the remaining product files are contained in the cabinet files EXCEL.1 through EXCEL.N (N might be 7, for example).</p>

		<p>To produce this disk layout with MakeCAB, a DDF is prepared which lists all of the files for the product, along with some optional MakeCAB settings to control parameters such as: 1) the capacity of the disks which are being used, 2) the naming convention of the cabinet files , 3) the visible (user-readable) labels on each disk, 4) how much random access is desired for files within a cabinet. The following is an example of a DDF that might be appropriate:</p>

		<pre class="code">;*** MakeCAB Directive file example
;
.OPTION EXPLICIT                     ; Generate errors on variable typos

.Set DiskLabel1=Setup                ; Label of first disk
.Set DiskLabel2=Program              ; Label of second disk
.Set DiskLabel3="Program Continued"  ; Label of third disk
.Set CabinetNameTemplate=EXCEL.*     ; EXCEL.1, EXCEL.2, etc.
.set DiskDirectoryTemplate=Disk*     ; disk1, disk2, etc.
.Set MaxDiskSize=1.44M               ; 3.5" disks

;** Setup.exe and setup.inf are placed uncompressed in the first disk
.Set Cabinet=off
.Set Compress=off
.Set InfAttr=                        ; Turn off read-only, etc. attrs
bin\setup.exe                        ; Just copy SETUP.EXE as is
bin\setup.inf                        ; Just copy SETUP.INF as is

;** The rest of the files are stored, compressed, in cabinet files
.Set Cabinet=on
.Set Compress=on
bin\excel.exe                        ; Big EXE, will span cabinets
bin\excel.hlp
bin\olecli.dll
bin\olesrv.dll
;...                                 ; Many more files
;*** &lt;the end&gt;                       ; That's it
</pre>

		<p>Now, you run MakeCAB to create the disk layout:</p>

		<pre class="code">MakeCAB /f excel.ddf
</pre>

		<p>MakeCAB will create directories Disk1, Disk2, etc. to hold the files for each disk, and will copy uncompressed files or create cabinet files (as appropriate) in each directory. The file SETUP.RPT will be written to the current directory (this can be overridden) with a summary of what MakeCAB did, and the file SETUP.INF will contain details on every disk and cabinet created, including a list of where each file was placed.</p>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#over">Overview</a> &gt; <a href="#case1">Case 1: MakeCAB for Setup Programs</a> </p>

		<h4 class="dtH1">
			<a id="case2"></a>Case 2: MakeCAB for a 200MB Source Code Archive</h4>

		<p>The Microsoft Developers Network (MSDN) CD includes over 200Mb of source code. While uncompressed this is only 1/3rd of the CD, that is still too much space, so tight compression is desired. This is slightly different from the Setup case, however, since there is a front-end tool that allows users to select sample programs and expand them onto the hard disk. </p>

		<p><strong>This section includes:</strong></p>

		<p><a href="#c2_chars">Characteristics of a Source Code Archive</a> </p>

		<p><a href="#c2_app">MakeCAB Application</a> </p>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> </p>

		<h4 class="dtH1">
			<a id="c2_chars"></a>Characteristics of a Source Code Archive</h4>

		<ol>
			<li>Minimizing space usage is slightly less important</li>

			<li>Files are accessed somewhat randomly, though in groups</li>

			<li>Only a small portion of the files will be accessed at any one time</li>
		</ol>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#over">Overview</a> &gt; <a href="#case2">Case 2: MakeCAB for a 200Mb Source Code Archive</a> </p>

		<h4 class="dtH1">
			<a id="c2_app"></a>MakeCAB Application</h4>

		<p>The cabinet files produced for the source archive need to be big enough to provide good compression, but not so big that random access speed is sacrificed. The challenge is to obtain a good tradeoff between compression and access time.</p>

		<pre class="code">;*** MSDN Sample Source Code MakeCAB Directive file example
;
.OPTION EXPLICIT                  ; Generate errors on variable typos

.Set CabinetNameTemplate=MSDN.*   ; MSDN.1, MSDN.2, etc.
.set DiskDirectoryTemplate=CDROM  ; All cabinets go in a single directory
.Set MaxDiskFileCount=1000        ; Limit file count per cabinet, so that
								  ; scanning is not too slow
.Set FolderSizeThreshold=200000   ; Aim for ~200K per folder
.Set CompressionType=MSZIP

;** All files are compressed in cabinet files
.Set Cabinet=on
.Set Compress=on
foo.c
foo.h
....
;*** &lt;the end&gt;                    ; That's it
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#over">Overview</a> &gt; <a href="#case2">Case 2: MakeCAB for a 200Mb Source Code Archive</a> </p>

		<h4 class="dtH1">
			<a id="case3"></a>Case 3: Self-extracting Cabinet File(s)</h4>

		<p>Many times, a software developer will want to ship executables, libraries, or the like across an Intranet or the Internet. They need a small package and an easy way for users to extract data. For example, Java[TM] developers may want to ship large libraries of classes, so that home and business developers can use those classes in their software.</p>

		<p>EXTRACT.EXE, which extracts files from CAB files, recognizes when it has been copied to the front of a cabinet file, and will automatically extract the files in that cabinet file (and any continuation cabinet files). Here is how this is accomplished:

		</p>
		<ol>
			<li>Create a cabinet file (or set of cabinet files).</li>

			<li>Prepend EXTRACT.EXE to the first cabinet file (do not prepend EXTRACT.EXE to any other cabinet files in the set).</li>

			<li>Distribute the self-extracting cabinet (and any subsequent cabinets).</li>
		</ol>

		<p class="label"><strong>Example:</strong></p>

		<pre class="code">MakeCAB /f self.ddf                     ; Build cabinet file set self1.cab, self2.cab
copy /b extract.exe+self1.cab self.exe  ; self.exe is self-extracting
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#over">Overview</a> </p>

		<h4 class="dtH1">
			<a id="deliverables"></a>MakeCAB Deliverables</h4>

		<p>The following table is a list of all the libraries and programs that are part of MakeCAB:</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">File</th>
						<th scope="col">Contents</th>
					</tr>

					<tr>
						<td data-th="File">MAKECAB.EXE</td>
						<td data-th="Contents">Command-line tool to perform disk layout (uses FCI.LIB)</td>
					</tr>

					<tr>
						<td data-th="File">FDI.LIB</td>
						<td data-th="Contents">File Decompression Interface library.</td>
					</tr>

					<tr>
						<td data-th="File">EXTRACT.EXE</td>
						<td data-th="Contents">Command-line tool to expand files (uses FDI.LIB)</td>
					</tr>

					<tr>
						<td data-th="File">FCI.LIB</td>
						<td data-th="Contents">File Compression Interface library.</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#over">Overview</a> </p>

		<h4 class="dtH1">
			<a id="makecabgoals"></a>MakeCAB Goals</h4>

		<ul>
			<li>Provide excellent compression ratio and decompression speed</li>

			<li>Simplify production of disk layouts for products</li>

			<li>Provide command-line tools and link libraries for all Microsoft platforms</li>
		</ul>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#over">Overview</a> </p>

		<h3 class="dtH1">
			<a id="makecaboptimizingandtuning"></a>MakeCAB Optimizing and Tuning</h3>

		<p><strong>This section includes:</strong></p>

		<p><a href="#save">Saving Diskettes</a> </p>

		<p><a href="#tuning">Tuning Access Time vs. Compression Ratio</a> </p>

		<p><a href="#ddfs">Piecemeal DDFs for Localization and Different Disk Sizes</a> </p>

		<p><a href="#time">Creation Time</a> </p>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> </p>

		<h4 class="dtH1">
			<a id="save"></a>Saving Diskettes</h4>

		<p>For a product shipped on floppy disks, it is very important to minimize the number of disks shipped per product! As a back-of-the-envelope calculation, if each disk cost a dollar and one million units were shipped, then each disk saved would save $1 million. The following pseudo-code suggests a process you might follow as you strive to keep your Cost of Goods Sold (COGS) to a minimum:</p>

		<pre class="code">get initial product files;
while (have not yet shipped)
   Compress file set using:
	  CompressionType=LZX
	  CompressionMemory=21
   If near a disk boundary
	  Consider tossing files to save a disk (especially clipart &amp; samples!)
   If near shipping
	  Relax FolderSizeThreshold to
	  improve access time at decompress.
end-while
Ship it!
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecaboptimizingandtuning">MakeCAB Optimizing and Tuning</a> </p>

		<h4 class="dtH1">
			<a id="tuning"></a>Tuning Access Time vs. Compression Ratio</h4>

		<p>MakeCAB introduces the concept of a <em>folder </em>to refer to a contiguous set of compressed bytes. To decompress a file from a cabinet, FDI.LIB (called by your SETUP.EXE and EXTRACT.EXE) finds the folder that the file starts in, and then must <strong>read and decompress </strong>all the bytes in that folder from the start up through and including the desired file.</p>

		<p>For example, if the file FOO.EXE is at the end of a 1.44Mb folder on a 1.44M diskette, then FDI.LIB must read the entire diskette and decompress all the data. This is about the worst access time possible. By contrast, if FOO.EXE were at the start of a folder (regardless of how large the folder is), then it would be read and decompressed with no extra overhead.</p>

		<p>So, why would one not always Set FolderFileCountThreshold=1? Because doing so would reset the compression history after each file, resulting in a poor compression ratio. MakeCAB provides several variables and directives to provide very fine control over these issues:</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Variable/Directive</th>
						<th scope="col">More Compression; <br> Slower Access Time</th>
						<th scope="col">Less Compression; <br> Faster Access Time</th>
					</tr>

					<tr>
						<td data-th="Variable/Directive">CabinetFileCountThreshold</td>
						<td data-th="More Compression; 
Slower Access Time">Bigger numbers</td>
							<td data-th="Less Compression; 
Faster Access Time">Lower numbers</td>
					</tr>

					<tr>
						<td data-th="Variable/Directive">FolderFileCountThreshold</td>
						<td data-th="More Compression; 
Slower Access Time">Bigger numbers</td>
							<td data-th="Less Compression; 
Faster Access Time">Lower numbers</td>
					</tr>

					<tr>
						<td data-th="Variable/Directive">FolderSizeThreshold</td>
						<td data-th="More Compression; 
Slower Access Time">Bigger numbers</td>
							<td data-th="Less Compression; 
Faster Access Time">Lower numbers</td>
					</tr>

					<tr>
						<td data-th="Variable/Directive">MaxCabinetSize</td>
						<td data-th="More Compression; 
Slower Access Time">Bigger numbers</td>
							<td data-th="Less Compression; 
Faster Access Time">Lower numbers</td>
					</tr>

					<tr>
						<td data-th="Variable/Directive">.New Folder</td>
						<td data-th="More Compression; 
Slower Access Time">Don't use</td>
							<td data-th="Less Compression; 
Faster Access Time">Use often</td>
					</tr>

					<tr>
						<td data-th="Variable/Directive">.New Cabinet</td>
						<td data-th="More Compression; 
Slower Access Time">Don't use</td>
							<td data-th="Less Compression; 
Faster Access Time">Use often</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>The MakeCAB defaults are configured for a floppy disk layout, with the assumption that the most common scenario is a full setup that will extract most of the files, so these are the settings:</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Variable/Directive</th>
						<th scope="col">Value</th>
					</tr>

					<tr>
						<td data-th="Variable/Directive">CabinetFileCountThreshold</td>
						<td data-th="Value">2000 (Since we have to call FDICopy() on a cabinet and walk through all the FILE headers, we want this small enough so that isn't too much overhead, but large enough to keep the number of cabinets down.)</td>
					</tr>

					<tr>
						<td data-th="Variable/Directive">FolderFileCountThreshold</td>
						<td data-th="Value">Unlimited (Let FolderSizeThreshold control folder size!)</td>
					</tr>

					<tr>
						<td data-th="Variable/Directive">FolderSizeThreshold</td>
						<td data-th="Value">200K (Represents 600K-800K of source (assuming 3:1 or 4:1 compression ratio)</td>
					</tr>

					<tr>
						<td data-th="Variable/Directive">MaxCabinetSize</td>
						<td data-th="Value">Unlimited (Let CabinetFileCountThreshold control the cabinet size!)</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Of course, if you are tight for space on your CD-ROM, you'll probably boost the <strong>FolderSizeThreshold</strong> and <strong>CompressionMemory</strong> settings!</p>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecaboptimizingandtuning">MakeCAB Optimizing and Tuning</a> </p>

		<h4 class="dtH1">
			<a id="ddfs"></a>Piecemeal DDFs for Localization and Different Disk Sizes</h4>

		<p>MAKECAB.EXE was designed to minimize the amount of duplicate information needed to generate product layouts for different languages and disk sizes. A key feature is the ability to specify more than one DDF on the MAKECAB.EXE command line. For example:</p>
		<div class="tablediv">
			<table class="dtTABLE" summary="table">

				<tbody>
					<tr>
						<td>acme.ddf</td>
						<td>Some standard definitions to control the format of the output INF file</td>
					</tr>

					<tr>
						<td>lang.ddf</td>
						<td>Sets language-specific settings (SourceDir, for example)</td>
					</tr>

					<tr>
						<td>disk.ddf</td>
						<td>Sets the diskette sizes (CDROM, 1.2M, 1.44M, etc.)</td>
					</tr>

					<tr>
						<td>product.ddf</td>
						<td>Lists all the files in the product, and uses variables set in the previous DDFs to customize its operation</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>The following command line would be used to process this set of DDFs:</p>

		<pre class="code">MakeCAB /f acme.ddf /f lang.ddf /f disk.ddf /f product.ddf</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecaboptimizingandtuning">MakeCAB Optimizing and Tuning</a> </p>

		<h4 class="dtH1">
			<a id="time"></a>Creation Time</h4>

		<p>MakeCAB is generally used in scenarios where the time required for creation is not as important as the size or layout of the output. This is especially true when the output is created once and consumed many times. However, better compression ratios and increasingly complex layouts will result in longer MakeCAB execution times. Overall creation time can be minimized by reducing LZX CompressionMemory, using MSZIP, or turning off Compression. Because MakeCAB attempts to create Cabinets as optimally as possible, a greater number of Cabinets/disks may result in greatly increased creation times. Additionally, creation time can be reduced by reducing the complexity of the layout.</p>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecaboptimizingandtuning">MakeCAB Optimizing and Tuning</a> </p>

		<h3 class="dtH1">
			<a id="concepts"></a>MakeCAB Concepts</h3>

		<p>The key feature of MakeCAB is that it takes a set of files and produces a <em>disk layout </em>while at the same time attempting to minimize the number of disks required. In order to understand how MakeCAB does this, three terms need to be defined: <em>cabinet</em>, <em>folder</em>, and <em>file</em>. MakeCAB takes all of the <em>files</em> in the product or application being compressed, lays the bytes down as one continuous byte stream, compresses the entire stream, chopping it up into <em>folders</em> as appropriate, and then fills up one or more <em>cabinets </em>with the <em>folders</em>.

		</p>
		<dl>
			<dt><em>Cabinet</em></dt>

			<dd>A normal file that contains pieces of one or more files, usually compressed. Also known as a "CAB file".</dd>

			<dt><em>Folder</em></dt>

			<dd>A decompression boundary. Large folders enable higher compression, because the compressor can refer back to more data in finding patterns. However, to retrieve a file at the end of a folder, the entire folder must be decompressed. So there is a tradeoff between achieved compression and the quickness of random access to individual files.</dd>

			<dt><em>File</em></dt>

			<dd>A file to be placed in the layout.</dd>
		</dl>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> </p>

		<h4 class="dtH1">
			<a id="decoupling"></a>Decoupling File Layout and INF Layout</h4>

		<p>MakeCAB has two "modes" for generating the INF file; <em>unified mode</em> and <em>relational mode</em>. In <em>unified mode</em>, the INF file is generated as file copy commands are processed in the DDF file. This is the default, and minimizes the amount of effort needed to construct a DDF file. However, this forces the INF file to list the files in the layout in exactly the same order as they are placed on disks/cabinets.</p>

		<p class="label"><strong>Example of a Unified DDF:</strong></p>

		<pre class="code">;** Set up INF formats before we do the disk layout, because MakeCAB
;   writes Disk and Cabinet information out as it is generated.
.OPTION EXPLICIT            ; Generate errors for undefined variables

.Set InfDiskHeader="[disk list]"
.Set InfDiskHeader1=";&lt;disk number&gt;,&lt;disk label&gt;"
.Set InfDiskLineFormat="*disk#*,*label*"

.Set InfCabinetHeader="[cabinet list]"
.Set InfCabinetHeader1=";&lt;cabinet number&gt;,&lt;disk number&gt;,&lt;cabinet file name&gt;"
.Set InfCabinetLineFormat="*cab#*,*disk#*,*cabfile*"

.Set InfFileHeader=";*** File List ***"
.Set InfFileHeader1=";&lt;disk number&gt;,&lt;cabinet number&gt;,&lt;filename&gt;,&lt;size&gt;"
.Set InfFileHeader2=";Note: File is not in a cabinet if cab# is 0"
.Set InfFileHeader3=""
.Set InfFileLineFormat="*disk#*,*cab#*,*file*,*date*,*size*"


.set GenerateInf=ON         ; Unified mode - create the INF file as we go

;** Setup files.  These don't need to be in the INF file, so we put
;   /inf=NO on these lines so that MakeCAB won't generate an error when
;   it finds that these files are not mentioned in the INF portion of
;   the DDF.

.set Compress=OFF
.set Cabinet=OFF
setup.exe /inf=NO           ; This file doesn't show up in INF
setup.inf /inf=NO           ; This file doesn't show up in INF

;** Files in cabinets
.set Compress=ON
.set Cabinet=ON

;* Put all bitmaps together to help compression
a1.bmp                      ; Bitmap for client1.exe
b1.bmp                      ; Bitmap for client1.exe
c1.bmp                      ; Bitmap for client1.exe
d1.bmp                      ; Bitmap for client1.exe
a2.bmp                      ; Bitmap for client1.exe
b2.bmp                      ; Bitmap for client2.exe
c2.bmp                      ; Bitmap for client2.exe
d2.bmp                      ; Bitmap for client2.exe
shared.dll  /date=10/12/93  ; File needed by client1.exe and client2.exe
client1.exe                 ; needs shared.dll
client2.exe                 ; needs shared.dll

;*** The End
</pre>

		<p>In <em>relational mode</em> the DDF has <em>file reference</em> lines to specify the exact placement of file information lines, including the ability to list the same file multiple times. This feature is important for INF structures which use section headers (e.g. "[clipart]", "[screen savers]") to identify sets of files for particular functionality, and for which the same file may need to be included in more than one section. For example, a product may have several optional features, all of which require a DLL file named "shared.dll". Rather than having "shared.dll" stored multiple times (once for each section which uses the file), a waste of disk space, a single copy of the file can be stored, and then referenced by all of the sections which require it.</p>

		<p>A relational mode DDF is similar to a unified mode DDF, with the exception that a ".set GenerateInf=OFF" line must be inserted before the product's files are listed (as shown below). Once all of the files have been listed, the INF file generating portion of the DDF begins, and a ".set GenerateInf=ON" line must be inserted, followed by the section definitions.</p>

		<p class="label"><strong>Example of a Relational DDF:</strong></p>

		<pre class="code">   ;** Set up INF formats before we do the disk layout, because MakeCAB
   ;   writes Disk and Cabinet information out as it is generated.
   .OPTION EXPLICIT            ; Generate errors for undefined variables

   .Set InfDiskHeader="[disk list]"
   .Set InfDiskHeader1=";&lt;disk number&gt;,&lt;disk label&gt;"
   .Set InfDiskLineFormat="*disk#*,*label*"

   .Set InfCabinetHeader="[cabinet list]"
   .Set InfCabinetHeader1=";&lt;cabinet number&gt;,&lt;disk number&gt;,&lt;cabinet file name&gt;"
   .Set InfCabinetLineFormat="*cab#*,*disk#*,*cabfile*"

   .Set InfFileHeader=";*** File List ***"
   .Set InfFileHeader1=";&lt;disk number&gt;,&lt;cabinet number&gt;,&lt;filename&gt;,&lt;size&gt;"
   .Set InfFileHeader2=";Note: File is not in a cabinet if cab# is 0"
   .Set InfFileHeader3=""
   .Set InfFileLineFormat="*disk#*,*cab#*,*file*,*date*,*size*"


;
; *** Here is where we list all the files
;
   .set GenerateInf=OFF        ; RELATIONAL MODE - Do disk layout first

   ;** Setup files.  These don't need to be in the INF file, so we put
   ;   /inf=NO on these lines so that MakeCAB won't generate an error when
   ;   it finds that these files are not mentioned in the INF portion of
   ;   the DDF.

   .set Compress=OFF
   .set Cabinet=OFF
   setup.exe /inf=NO           ; This file doesn't show up in INF
   setup.inf /inf=NO           ; This file doesn't show up in INF

   ;** Files in cabinets
   ;
   .set Compress=ON
   .set Cabinet=ON

   ;* Put all bitmaps together to help compression
   a1.bmp                      ; Bitmap for client1.exe
   b1.bmp                      ; Bitmap for client1.exe
   c1.bmp                      ; Bitmap for client1.exe
   d1.bmp                      ; Bitmap for client1.exe
   a2.bmp                      ; Bitmap for client1.exe
   b2.bmp                      ; Bitmap for client2.exe
   c2.bmp                      ; Bitmap for client2.exe
   d2.bmp                      ; Bitmap for client2.exe
   shared.dll  /date=10/12/93  ; File needed by client1.exe and client2.exe
   client1.exe                 ; needs shared.dll
   client2.exe                 ; needs shared.dll


;
; *** Now we're generating the INF file
;
   .set GenerateInf=ON         

   ;** Feature One files
   .InfBegin File
   [feature One]
   ;Files for feature one
   .InfEnd
   client1.exe
   shared.dll  /date=04/01/94  ; Override date
   a1.bmp
   b1.bmp
   c1.bmp
   d1.bmp

   ;** Feature Two files
   .InfBegin File

   [feature Two]
   ;Files for feature Two
   ;Note that shared.dll is also required by Feature One
   .InfEnd
   client1.exe
   shared.dll
   a2.bmp
   b2.bmp
   c2.bmp
   d2.bmp

   ;*** The End
</pre>

		<p class="label"><strong>The generated INF file would look something like this:</strong></p>

		<pre class="code">[disk list]
;&lt;disk number&gt;,&lt;disk label&gt;
1,"Disk 1"

[cabinet list]
;&lt;cabinet number&gt;,&lt;disk number&gt;,&lt;cabinet file name&gt;
1,1,cabinet.1

;*** File List ***
;&lt;disk number&gt;,&lt;cabinet number&gt;,&lt;filename&gt;,&lt;size&gt;
;Note: File is not in a cabinet if cab# is 0

[feature One]
;Files for feature one
1,1,client1.exe,12/12/93,1234
1,1,shared.dll,04/01/94,1234
1,1,a1.bmp,12/12/93,573
1,1,b1.bmp,12/12/93,573
1,1,c1.bmp,12/12/93,573
1,1,d1.bmp,12/12/93,573

[feature Two]
;Files for feature Two
;Note that shared.dll is also required by Feature One
1,1,client1.exe,12/12/93,1234
1,1,shared.dll,10/12/93,1234
1,1,a2.bmp,12/12/93,643
1,1,b2.bmp,12/12/93,643
1,1,c2.bmp,12/12/93,643
1,1,d2.bmp,12/12/93,643
</pre>

		<p><strong>Notes:</strong>

		</p>
		<ol>
			<li>In "relational" mode, only the last setting of a particular <strong>Inf</strong>Xxx default parameter variable (both standard parameters like <strong>InfDate</strong>, <strong>InfTime</strong>, etc. and custom parameters) in the layout portion (i.e. the first part) of the DDF is respected.
				<p class="label"><strong>Example:</strong>

				</p>
				<p>If you did ".set <strong>InfDate</strong>=12/05/92" at the start of the layout portion, and then did ".set <strong>InfDate</strong>=01/01/94" in the middle of the layout portion, the latter value would be used for the entire INF file.
				</p>
			</li>

			<li>Any parameters on a reference line will override parameters on the corresponding file copy line.
				<p class="label"><strong>Example:</strong>

				</p>
				<pre class="code">;* layout portion
bar /x=1

;* INF portion
bar /x=2            ; INF file will have value 2
</pre>
			</li>

			<li>In "relational" mode, each file copy command in the layout portion of the DDF must be referenced at least once in a reference command in the INF portion of the DDF. Any files that are not referenced will cause an error during pass 1. The <strong>/inf</strong>=<strong>no</strong> parameter must be specified on any file copy commands for files which are going to be omitted from the INF file (such as SETUP.EXE and SETUP.INF).<br>
			</li>

			<li>In "relational" mode, <strong>UniqueFiles</strong> must be <strong>ON</strong>, because the destination file name is used in the INF portion of the DDF to refer back to file information.</li>
		</ol>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#concepts">MakeCAB Concepts</a> </p>

		<h3 class="dtH1">
			<a id="makecab_exe"></a>MAKECAB.EXE</h3>

		<p>MAKECAB.EXE is designed to produce the final distribution files and cabinets for an entire product in a single run. The most common way to use MAKECAB.EXE is to supply a <em>directives file </em>that controls how files are compressed and stored into one or more cabinets.</p>

		<p><strong>This section includes:</strong></p>

		<p><a href="#syntax">MAKECAB.EXE Syntax</a> </p>

		<p><a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> </p>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> </p>

		<h4 class="dtH1">
			<a id="syntax"></a>MAKECAB.EXE Syntax</h4>

		<p>There two primary forms of MAKECAB.EXE usage. The first is used for compressing a single file, while the second is used for compressing multiple files.</p>

		<pre class="code"><strong>MAKECAB</strong>  [<strong>/V</strong>n] [<strong>/D</strong> variable=value ...] [<strong>/L</strong> directory] source [destination]
<strong>MAKECAB</strong>  [<strong>/V</strong>n] [<strong>/D</strong> variable=value ] <strong>/F</strong> directives_file [...]
</pre>

		<p>The parameters are described below.</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Parameter</th>
						<th scope="col">Description</th>
					</tr>

					<tr>
						<td data-th="Parameter">source</td>
						<td data-th="Description">A file to be compressed.</td>
					</tr>

					<tr>
						<td data-th="Parameter">destination</td>
						<td data-th="Description">The name of the file to receive the compressed version of the source file. If not supplied, a default destination name is constructed from the source file name according to the rules defined by the <a href="#compfileext">CompressedFileExtensionChar</a> variable. You can use /D CompressedFileExtensionChar=c on the command line to change the appended character.</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>/D </strong>variable=value</td>
						<td data-th="Description">Set variable to be equal to value. Equivalent to using the <strong>.Set </strong>command in the directives file. For example, a single directive file could be used to produce layouts for different disk sizes by running MakeCAB once with different values of <strong>MaxDiskSize</strong> defined: /D MaxDiskSize=1.44M. Both standard MakeCAB variables and custom variables may be defined in this way. If <strong>.Option Explicit </strong>is specified in a directive file, then variable must be defined with a <strong>.Define </strong>command in a directive file.</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>/L </strong>directory</td>
						<td data-th="Description">Specifies an output directory where the compressed file will be placed (most useful when destination is not supplied).</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>/F</strong> directives_file</td>
						<td data-th="Description">A file containing commands for MAKECAB.EXE to execute. If more than one directive file is specified (/F file1 /F file2 ...), they are processed in the order (left to right) specified on the command line. Variable settings, open cabinets, open disks, etc. are all carried forward from one directive file to the next (just as if all of the files had been concatenated together and presented as a single file to MakeCAB). For example, this is intended to simplify the work for a product shipped in multiple languages. There would be a short, language-specific directives file, and then a single, large master directives file that covers the bulk of the product.</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>/V</strong>n</td>
						<td data-th="Description">Set debugging verbosity level (0=none,...,3=full)</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> </p>

		<h4 class="dtH1">
			<a id="dir_file_syntax"></a>MAKECAB.EXE Directive File Syntax</h4>

		<p>Before diving into the details of the syntax of the directives file, provided here is an example of what the Excel directives file might look like:</p>

		<pre class="code">;*** EXCEL MAKECAB Directive file
;
.Set DiskLabel1=Setup                ; Label of first disk
.Set DiskLabel2=Program              ; Label of second disk
.Set DiskLabel3="Program Continued"  ; Label of third disk
.Set CabinetNameTemplate=EXCEL*.CAB  ; EXCEL1.CAB, EXCEL2.CAB, etc.
.Set MaxDiskSize=1.44M               ; 3.5" disks

;** Setup.exe and setup.inf are placed uncompressed in the first disk
.Set Cabinet=off
.Set Compress=off
bin\setup.exe                        ; Just copy SETUP.EXE as is
bin\setup.inf                        ; Just copy SETUP.INF as is
;** The rest of the files are stored, compressed, in cabinet files
.Set Cabinet=on
.Set Compress=on
bin\excel.exe                        ; Big EXE, will span cabinets
bin\excel.hlp
bin\olecli.dll
bin\olesrv.dll
...
</pre>

		<p>Here are some additional notes on the general syntax and behavior of MakeCAB Directive Files:

		</p>
		<ol>
			<li>MakeCAB will place files on disks (and in cabinets) in the order they are specified in the directive file(s).</li>

			<li>When ever a filename or directory is called for, you may supply either a relative (e.g., foo\bar, ..\foo) or an absolute (e.g., c:\banana, x:\slm\src\bin) path.</li>

			<li>Optimal compression is achieved when files with similar types of data are grouped together.</li>

			<li>MakeCAB is controlled in large part by setting <em>variables</em>. MakeCAB has many predefined variables, all of which have default values chosen to represent the most common case. You can modify these variables, and you can define your own variables as well.</li>

			<li>The value of a variable is retrieved by enclosing the variable name in percent (%) signs. If the variable is not defined, an error is generated. If you want an explicit percent sign, use two adjacent percent signs (%%). MakeCAB will collapse this to a single percent sign (%).</li>

			<li>Variable substitution is only done once. For example, .Set A=One [A is "One"]; .Set B=%%A%% (B is "%A%"); .Set C=%B% (C is "%A%", <strong>not </strong>"One").</li>

			<li>Variable substitution is done before any other line parsing, so variables can be used anywhere.</li>

			<li>Variables values may include blanks. Quote (") or apostrophe(') marks may be used in .Set statements to capture blanks. If you want an explicit quote(") or apostrophe('), you can intermix these two marks (use one for bracketing so that you may specify the other), or, as with the percent sign above, you can specify two adjacent marks ("") and MakeCAB will collapse this to a single mark(").</li>

			<li>All sizes are specified in bytes.</li>

			<li>There are a few special values for common disks sizes (CDROM, 1.44M, 1.2M, 720K, 360K) that can be used for any of the predefined MakeCAB variables that describe the attributes of a disk (<strong>MaxDiskSize</strong>, <strong>ClusterSize</strong>, <strong>MaxDiskFileCount</strong>). MakeCAB has built-in knowledge about the correct values of these attributes for these common disk sizes.</li>

			<li>MakeCAB does not check for 8.3 filename limitations directly, but rather depends upon the underlying operating system to do filename validity checking (this will allow MakeCAB to work with long file names.)</li>

			<li>MakeCAB makes two passes of the directive file(s). On the first pass, MakeCAB checks for syntax errors and makes sure that all of the files can be found. This is very fast, and reduces the chance that the second pass, where the actual data compression occurs, will have any problems. This is important because compression is very time consuming, so MakeCAB wants to avoid, for example, spending an hour compressing files only to find that a file toward the end of the directive file(s) cannot be found.</li>

			<li>There is a limit of 1024 characters per line in a Directive File.</li>

			<li>There is a limit of 1024 lines in a Directive File.</li>
		</ol>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> </p>

		<p><strong>This section includes:</strong></p>

		<p><a href="#com">Command Summary</a> </p>

		<p><a href="#var">Variable Summary</a> </p>

		<p><a href="#semantics">InfDisk/Cabinet/FileLineFormat Syntax and Semantics</a> </p>

		<p><a href="#inf">INF Parameters</a> </p>

		<p><a href="#com_details">Command Details</a> </p>

		<p><a href="#var_details">Variable Details</a> </p>

		<h4 class="dtH1">
			<a id="com"></a>Command Summary</h4>

		<p>The following table provides a summary of the MakeCAB Directive File syntax. Directives begin with a period ("."), followed by a command name, and possibly by blank delimited arguments. Note that a File Copy command is distinguished from a File Reference command by the setting of the <strong>GenerateInf</strong> variable.</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Syntax</th>
						<th scope="col">Description</th>
					</tr>

					<tr>
						<td data-th="Syntax">;</td>
						<td data-th="Description">Comment (anywhere on a DDF line)</td>
					</tr>

					<tr>
						<td data-th="Syntax">src [dest] [<strong>/inf=yes|no</strong>] [<strong>/unique=yes|no</strong>] [/x=y ...]</td>
						<td data-th="Description">File Copy command</td>
					</tr>

					<tr>
						<td data-th="Syntax">dest [/x=y ...]</td>
						<td data-th="Description">File Reference command</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.Define</strong> variable=[value]</td>
						<td data-th="Description">Define <em>variable</em> to be equal to <em>value </em>(see .Option Explicit)</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.Delete</strong> variable</td>
						<td data-th="Description">Delete a variable definition</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.Dump</strong> </td>
						<td data-th="Description">Display all variable definitions</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.InfBegin Disk | Cabinet | Folder</strong> </td>
						<td data-th="Description">Copy lines to specified INF file section</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.InfEnd</strong> </td>
						<td data-th="Description">End an <strong>.InfBegin</strong> section</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.InfWrite</strong> string</td>
						<td data-th="Description">Write "string" to file section of INF file</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.InfWriteCabinet</strong> string</td>
						<td data-th="Description">Write "string" to cabinet section of INF file</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.InfWriteDisk</strong> string</td>
						<td data-th="Description">Write "string" to disk section of INF file</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.New Disk | Cabinet | Folder</strong> </td>
						<td data-th="Description">Start a new Disk, Cabinet, or Folder</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.Option Explicit</strong> </td>
						<td data-th="Description">Require <strong>.Define</strong> first time for user-defined variables</td>
					</tr>

					<tr>
						<td data-th="Syntax"><strong>.Set</strong> variable=[value]</td>
						<td data-th="Description">Set <em>variable</em> to be equal to <em>value</em></td>
					</tr>

					<tr>
						<td data-th="Syntax">%variable%</td>
						<td data-th="Description">Substitute value of <em>variable</em></td>
					</tr>

					<tr>
						<td data-th="Syntax"><em>&lt;blank line&gt;</em></td>
						<td data-th="Description">Blank lines are ignored</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> </p>

		<h4 class="dtH1">
			<a id="var"></a>Variable Summary</h4>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Standard Variables</th>
						<th scope="col">Description</th>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>Cabinet</strong>=<strong>ON </strong>|<strong> OFF</strong></td>
						<td data-th="Description">Turns Cabinet Mode on or off</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>CabinetFileCountThreshold</strong>=count</td>
						<td data-th="Description">Threshold count of files per Cabinet</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>CabinetName</strong><em>n</em>=filename</td>
						<td data-th="Description">Cabinet file name for cabinet number <em>n</em></td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>CabinetNameTemplate</strong>=template</td>
						<td data-th="Description">Cabinet file name template; * is replaced by Cabinet number</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>ChecksumWidth</strong>=<strong>1</strong> | <strong>2</strong> | ... | <strong>8</strong></td>
						<td data-th="Description">Max low-order hex digits displayed by INF <strong>csum</strong> parameter</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>ClusterSize=</strong>bytesPerCluster</td>
						<td data-th="Description">Cluster size on diskette (default is 512 bytes)</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>Compress</strong>=<strong>ON </strong>|<strong> OFF</strong></td>
						<td data-th="Description">Turns compression on or off</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>CompressedFileExtensionChar</strong>=char</td>
						<td data-th="Description">Last character of the file extension for compressed files</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>CompressionMemory</strong>=<strong>15</strong> | <strong>16</strong> | ... | <strong>21</strong></td>
						<td data-th="Description">The window size for LZX compression</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>CompressionType</strong>=<strong>MSZIP | LZX</strong></td>
						<td data-th="Description">Compression engine</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>DestinationDir=</strong>path</td>
						<td data-th="Description">Default path for destination files (stored in cabinet file)</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>DiskDirectory</strong><em>n</em>=directory</td>
						<td data-th="Description">Output directory name for disk <em>n</em></td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>DiskDirectoryTemplate</strong>=template</td>
						<td data-th="Description">Output directory name template; * is replaced by disk number</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>DiskLabel</strong><em>n</em>=label</td>
						<td data-th="Description">Printed disk label name for disk <em>n</em></td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>DiskLabelTemplate</strong>=template</td>
						<td data-th="Description">Printed disk label name template; * is replaced by disk number</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>DoNotCopyFiles</strong>=<strong> ON</strong> | <strong>OFF</strong></td>
						<td data-th="Description">Controls whether files are actually copied (ACME ADMIN.INF)</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>FolderFileCountThreshold</strong>=count</td>
						<td data-th="Description">Threshold count of files per Folder</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>FolderSizeThreshold</strong>=size</td>
						<td data-th="Description">Threshold folder size for current folder</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>GenerateInf</strong>=<strong>ON</strong> | <strong>OFF</strong></td>
						<td data-th="Description">Control Unified vs. Relation INF generation mode</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>Inf</strong><em>Xxx</em>=string</td>
						<td data-th="Description">Set default value for INF Parameter Xxx</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfCabinetHeader</strong>[<em>n</em>]=string</td>
						<td data-th="Description">INF cabinet section header text</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfCabinetLineFormat</strong>[<em>n</em>]=format string</td>
						<td data-th="Description">INF cabinet section detail line format</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfCommentString</strong>=string</td>
						<td data-th="Description">INF comment string</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfDateFormat</strong>=<strong>yyyy-mm-dd</strong> | <strong>mm/dd/yy</strong></td>
						<td data-th="Description">INF date format</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfDiskHeader</strong>[<em>n</em>]=string</td>
						<td data-th="Description">INF disk section header text</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfDiskLineFormat</strong>[<em>n</em>]=format string</td>
						<td data-th="Description">INF disk section detail line format</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfFileHeader</strong>[<em>n</em>]=string</td>
						<td data-th="Description">INF file section header text</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfFileLineFormat</strong>[<em>n</em>]=format string</td>
						<td data-th="Description">INF file section detail line format</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfFileName</strong>=filename</td>
						<td data-th="Description">Name of INF file</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfFooter</strong>[<em>n</em>]=string</td>
						<td data-th="Description">INF footer text</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfHeader</strong>[<em>n</em>]=string</td>
						<td data-th="Description">INF header text</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>InfSectionOrder</strong>=[<strong>D </strong>| <strong>C </strong>| <strong>F</strong>]*</td>
						<td data-th="Description">INF section order (disk, cabinet, file)</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>MaxCabinetSize</strong>=size</td>
						<td data-th="Description">Maximum cabinet file size for current cabinet</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>MaxDiskFileCount</strong>=count</td>
						<td data-th="Description">Maximum count of files per Disk</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>MaxDiskSize</strong>[<em>n</em>]=size</td>
						<td data-th="Description">Maximum disk size</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>MaxErrors</strong>=count</td>
						<td data-th="Description">Maximum errors allowed before pass 1 terminates</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>ReservePerCabinetSize</strong>=size</td>
						<td data-th="Description">Base amount of space to reserve for FCRESERVE data</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>ReservePerDataBlockSize</strong>=size</td>
						<td data-th="Description">Amount of space to reserve in each data block</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>ReservePerFolderSize</strong>=size</td>
						<td data-th="Description">Amount of additional space in FCRESERVE for each folder</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>RptFileName</strong>=filename</td>
						<td data-th="Description">Name of RPT file</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>SourceDir</strong>=path</td>
						<td data-th="Description">Default path for source files</td>
					</tr>

					<tr>
						<td data-th="Standard Variables"><strong>UniqueFiles</strong>=<strong>ON | OFF</strong></td>
						<td data-th="Description">Control whether duplicate destination file names are allowed</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> </p>

		<h4 class="dtH1">
			<a id="semantics"></a>InfDisk/Cabinet/FileLineFormat Syntax and Semantics</h4>

		<p>The <strong>InfDiskLineFormat</strong>, <strong>InfCabinetLineFormat</strong>, and <strong>InfFileLineFormat </strong>variables are used to control the formatting of the "detail" lines in the INF file. The syntax of the values assigned to these variables is as follows:

		</p>
		<ol>
			<li>The "*" character is used to bracket replaceable parameters.</li>

			<li>Two "*" characters in a row ("**") are replaced by a single "*".</li>

			<li>A replaceable parameter name may be one of the standard ones defined by MakeCAB, or it may be a custom parameter. The value used for a parameter is found in the following order:
				<ol>
					<li>If a parameter is specified on a File Copy or File Reference command, the specified value is used.</li>

					<li>If a variable InfXxxx is defined for this parameter, its value is used. The parameter is a standard parameter, and its defined value is used.</li>
				</ol>
			</li>

			<li>Braces "{}" may be used to indicate portions of text plus exactly one parameter that are omitted if the parameter value is blank. For example, "{*id*,}*file*,*size*" will generate the following strings, depending upon the values of id, file, and size:
				<div class="tablediv">
					<table class="dtTABLE" responsive="true" summary="table">

						<tbody>
							<tr responsive="true">
								<th scope="col">id</th>
								<th scope="col">file</th>
								<th scope="col">size</th>
								<th scope="col">Output String</th>
							</tr>

							<tr>
								<td data-th="id">&nbsp;</td>
								<td data-th="file">foo.dat</td>
								<td data-th="size">23</td>
								<td data-th="Output String">foo.dat,23</td>
							</tr>

							<tr>
								<td data-th="id">17</td>
								<td data-th="file">foo.dat</td>
								<td data-th="size">23</td>
								<td data-th="Output String">17,foo.dat,23</td>
							</tr>

							<tr>
								<td data-th="id">17</td>
								<td data-th="file">&nbsp;</td>
								<td data-th="size">23</td>
								<td data-th="Output String">17,,23</td>
							</tr>
						</tbody>
					</table>
				</div>
			</li>
		</ol>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> </p>

		<h4 class="dtH1">
			<a id="inf"></a>INF Parameters</h4>

		<p>The following table lists the standard parameters that may be specified in INF line formats and on File Copy and File Reference commands. The Disk, Cab, and File columns indicate which parameters are supported in the <strong>InfDiskLineFormat</strong>, <strong>InfCabinetLineFormat</strong>, and <strong>InfFileLineFormat</strong>, respectively. In addition, the File column also indicates which parameters may be specified on the File Copy and File Reference commands.</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Parameter</th>
						<th scope="col">Disk</th>
						<th scope="col">Cab</th>
						<th scope="col">File</th>
						<th scope="col">Description</th>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>attr</strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">File attributes (A=archive, R=read-only, H=hidden, S=system)</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>cab#    </strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">Yes</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">Cabinet number (0 means not in cabinet, 1 or higher is cabinet number)</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>cabfile </strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">Yes</td>
						<td data-th="File">&nbsp;</td>
						<td data-th="Description">Cabinet file name</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>csum    </strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">Checksum</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>date    </strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">File date (mm/dd/yy or yyyy-mm-dd, depending upon <strong>InfDateFormat</strong>)</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>disk#    </strong></td>
						<td data-th="Disk">Yes</td>
						<td data-th="Cab">Yes</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">Disk number (1-based)</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>file    </strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">Destination file name in layout (in cabinet or on a disk)</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>file#    </strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">Destination file number in layout (first file is 1, second file is 2, ...); the order of File Copy Commands controls the file number, so in relational INF mode the order of File Reference Commands has no affect on the file number.</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>label   </strong></td>
						<td data-th="Disk">Yes</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">&nbsp;</td>
						<td data-th="Description">Disk user-readable label (value comes from <strong>DiskLabel</strong><em>n</em>, if defined, and otherwise is constructed from <strong>DiskLabelTemplate</strong>).</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>lang    </strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">Language (i.e., VER.DLL info) in base 10, blank separated if multiple values </td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>size    </strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">File size (only affects value written to INF file)</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>time</strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">File time (hh:mm:ss[a|p])</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>ver</strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">Binary File version (n.n.n.n base 10 format)</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>vers</strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">String File version -- can be different from <strong>ver</strong>!</td>
					</tr>

					<tr>
						<td data-th="Parameter"><strong>attr</strong></td>
						<td data-th="Disk">&nbsp;</td>
						<td data-th="Cab">&nbsp;</td>
						<td data-th="File">Yes</td>
						<td data-th="Description">File attributes (A=archive, R=read-only, H=hidden, S=system)</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Just as custom INF parameters can be defined by using the <strong>.Define</strong> and <strong>.Set</strong> command (e.g., <strong>.Set </strong>InfCustom=default value), the <strong>.Set</strong> command can also be used to override the values of these parameters. This is most obviously useful for the <strong>date </strong>and <strong>time </strong>parameters, as it provides a simple way to "date stamp" all the files in a layout; and for the <strong>attr </strong>parameter, this provides a way to force a consistent set of file attributes (commonly used to clear the read-only and archive attribute bits).</p>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> </p>

		<h4 class="dtH1">
			<a id="com_details"></a>Command Details</h4>

		<dl>
			<dt><strong>;</strong></dt>

			<dd>A comment line.<br> A comment may appear anywhere in a directive file. In addition, any line may include a comment at the end. Any text on the line following the comment is ignored.

				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>
				</p>
			</dd>

			<dt>source [destination] [<strong>/INF= YES </strong>| <strong>NO</strong>] [<strong>/UNIQUE=YES</strong> | <strong>NO</strong>] [<strong>/x=y</strong> [<strong>/x=y</strong> ...]]</dt>

			<dd>A File Copy Command; specifies a file to be placed onto a disk or cabinet. If <strong>GenerateInf</strong> is <strong>OFF</strong>, then lines without leading periods are interpreted as File Copy Commands.

				<p><em>source </em>is a file name, and may include a relative or absolute path specification. The <strong>SourceDir </strong>variable is applied first, if specified.


				</p>
				<p><em>destination </em>is the name to store in the cabinet file (if <strong>Cabinet </strong>is <strong>On</strong>), or the name for the destination file (if <strong>Cabinet </strong>is <strong>Off</strong>). The <strong>DestinationDir </strong>variable is used as a prefix.<strong> /INF</strong>=<strong>YES </strong>| <strong>NO</strong> controls whether <em>destination</em> must specified in a Reference command in the INF section of the DDF. If <strong>YES</strong> is specified (the default), then <em>destination </em>must be specified in at least one Reference command. If <strong>NO </strong>is specified, then <em>destination </em>does not have to be specified in any Reference command. This parameter is used only if Relational INF mode is selected (see the <strong>GenerateInf</strong> variable), as Unified mode does not support Reference commands.


				</p>
				<p><strong>/UNIQUE</strong>=<strong>YES </strong>| <strong>NO</strong> controls whether <em>destination</em> must be unique throughout the layout. Specifying this parameter on the file copy command overrides the default setting controlled by the <strong>UniqueFiles</strong> variable (which defaults to YES). If Relational INF mode is selected (see the <strong>GenerateInf</strong> variable), then <strong>UniqueFiles</strong> must be <strong>YES</strong>.


				</p>
				<p><strong>/x</strong>=<strong>y </strong>permits standard and custom INF parameters to be applied to a file copy command. These parameters are carried along with the file by MakeCAB and used to format file detail lines in the INF file. In addition, the <strong>/Date</strong>, <strong>/Time</strong>, and <strong>/Attr</strong> parameters also control the values that are placed in the cabinet files or on the disk layout (for files outside of a cabinet). This permits a great deal of flexibility in customizing the INF file format. A parameter "x" is defined to have the value "y" (which may be empty). Quotes can be used in "y" to include blanks or other special characters. If a parameter "x" is also defined on a File Reference command, that setting overrides any setting for "x" specified on the referred to File Copy command. See <a href="#inf">INF Parameters</a> for a list of standard parameters.
				</p>
			</dd>
		</dl>

		<blockquote class="dtBlock">
			<strong>NOTE:</strong> <strong>You must define a variable InfX if you are going to use /X=y on a File Copy (or File Reference) command.</strong> If no such variable is defined, then /X=y will generate an error. This behavior ensures that there is a default value for every parameter, and makes it easier to catch inadvertent typing errors.</blockquote>

		<p>If the <em>destination </em>is not specified, its default value depends upon the <strong>Cabinet</strong> and <strong>Compress</strong> variables, as indicated by the following table, using BIN\EXCEL.EXE as a sample source file name. Note that the variable <strong>CompressedFileExtensionChar </strong>controls the actual character used to indicate a compressed file. Note also that the <strong>DestinationDir </strong>variable is prefixed to the destination name before it is stored in the cabinet file.</p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">&nbsp;</th>
						<th scope="col">Compress = OFF</th>
						<th scope="col">Compress = ON</th>
					</tr>

					<tr>
						<td data-th="&nbsp;"><strong>Cabinet = OFF</strong></td>
						<td data-th="Compress = OFF">EXCEL.EXE -- uncompressed, not in a cabinet.</td>
						<td data-th="Compress = ON">This scenario is not supported -- See note below.</td>
					</tr>

					<tr>
						<td data-th="&nbsp;"><strong>Cabinet = ON</strong></td>
						<td data-th="Compress = OFF">EXCEL.EXE -- uncompressed, in a cabinet.</td>
						<td data-th="Compress = ON">EXCEL.EXE -- compressed, in a cabinet</td>
					</tr>
				</tbody>
			</table>
		</div>

		<blockquote class="dtBlock">
			<strong>NOTE:</strong> Compressing a single file is generally not a good idea, as better compression is achieved by compressing across file boundaries (hence cabinet files). For this reason, MakeCAB does not support this case.</blockquote>

		<p class="label"><strong>Examples:</strong></p>

		<pre class="code">.Set Compress=OFF             ; Turn off compression
.Set Cabinet=OFF              ; No cabinet file
setup.exe /inf=no             ; Setup is put on disk 1, won't be in INF
setup.inf                     ; Classic chicken &amp; the egg problem

.Set Compress=ON              ; Turn compression on
readme.txt                    ; Placed on disk 1 as README.TX_
.Set Cabinet=ON               ; Turn cabinet file creation on
bin\excel.exe                 ; Placed in cabinet as EXCEL.EXE
msdraw.exe msapps\msdraw.exe  ; Placed in cabinet as MSAPPS\MSDRAW.EXE
a.txt dup.txt /unique=no      ; Another dup.txt is allowed
b.txt dup.txt /unique=no      ; And here it is
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>

		</p>
		<dl>
			<dt>destination [<strong>/x=y</strong> [<strong>/x=y</strong> ...]]</dt>

			<dd>A File Reference Command; specifies that information for a file (previously specified in a File Copy command) is to be written to the File section of the INF file. This command is only supported in Relational INF mode. If <strong>GenerateInf</strong> is <strong>ON</strong>, then lines without leading periods are interpreted as File Reference Commands.

				<p><em>destination </em>is the name of a file previously specified in a File Copy command as the <strong>destination </strong>in the layout (not the source!). Therefore, <strong>UniqueFiles</strong> is required to be <strong>ON</strong>.


				</p>
				<p><strong>/x</strong>=<strong>y </strong>permits standard and custom INF parameters to be applied to a file reference command. These parameters are merged with any parameters specified on the referenced File Copy command, with parameters on the File Reference command taking precedence.


				</p>
				<p>A parameter "x" is defined to have the value "y" (which may be empty). Quotes can be used in "y" to include blanks or other special characters. . See <a href="#inf">INF Parameters</a> for a list of standard parameters.
				</p>
			</dd>
		</dl>

		<blockquote class="dtBlock">
			<strong>NOTE:</strong> <strong>You must define a variable InfX if you are going to use /X=y on a File Reference (or File Copy) command.</strong> If no such variable is defined, then /X=y will generate an error. This behavior ensures that there is a default value for every parameter, and makes it easier to catch inadvertent typing errors.</blockquote>

		<p class="label"><strong>Examples:</strong></p>

		<pre class="code">.Set GenerateInf=OFF     ; Relational INF mode; file layout
setup.exe /inf=no        ; Setup is put on disk 1, won't be in INF
readme.txt
shared.dll /special=yes  ; Custom parameter

.Set GenerateInf=ON      ; INF section of DDF
.InfWrite [Common]
readme.txt
.InfWrite [One]
shared.dll /special=no   ; Override parm on file copy command
.InfWrite [Two]
shared.dll               ; Use /special value from file copy
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>

		</p>
		<dl>
			<dt><strong>.Define</strong> variable=[value]</dt>

			<dd>Define <em>variable </em>to be equal to <em>value</em>.

				<p>To use <em>variable</em>, surround it with percent signs (%) -- %variable%.


				</p>
				<p>Using an undefined variable is an error, and will cause MakeCAB to stop before pass 2.


				</p>
				<p><em>value </em>may include references to other variables.


				</p>
				<p>Leading and trailing blanks in <em>value </em>are discarded.


				</p>
				<p>Blanks may be enclose in quote (") or apostrophe (') marks.


				</p>
				<p>Explicit percent signs (%), quotes ("), or apostrophes (') must be specified twice.
				</p>
			</dd>
		</dl>

		<blockquote class="dtBlock">
			<strong>NOTE:</strong> If <strong>.Option Explicit </strong>is specified, then you must first use <strong>.Define </strong>to define any user-defined variables before you can use <strong>.Set </strong>to modify them. For standard MakeCAB variables, <strong>.Define </strong>is not permitted, and only <strong>.Set </strong>may be used on. If <strong>.Option Explicit </strong>is not specified, then <strong>.Define </strong>is equivalent to <strong>.Set</strong>.</blockquote>

		<p class="label"><strong>Examples:</strong></p>

		<pre class="code">.Define lang=ENGLISH                ; Set language
.Define country=USA                 ; Set country
.Define SourceDir=%lang%\%country%  ; SourceDir = [ENGLISH\USA]
.Define join=%lang%%country%        ; join = [ENGLISHUSA]
.Define success=100%%               ; success = [100%]
.Define SourceDir=                  ; SourceDir = []
.Define contraction="don't"         ; contraction = [don't]
.Define contraction=don''t          ; contraction = [don't]
.Define someSpaces=  hi there       ; someSpaces = [hi there]
.Define someMore="  blue dog  "     ; someMore = [  blue dog  ]
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>

		</p>
		<dl>
			<dt><strong>.Delete</strong> variable</dt>

			<dd>Delete a variable definition.

				<p>You may only delete variables that have been created by <strong>.Define </strong>or <strong>.Set </strong>commands. Standard MakeCAB variables may not be deleted.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set myVariable=raisin
.Delete myVariable      ; Delete myVariable
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>
				</p>
			</dd>

			<dt><strong>.Dump</strong></dt>

			<dd>Display the entire MakeCAB variable table.

				<p>This command can be used to aid debugging of complicated (or not so complicated) MakeCAB directive files. Note that the dump will be displayed during pass 1 and again during pass 2.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Dump               ; Dump variable table to stdout
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>
				</p>
			</dd>

			<dt><strong>.InfBegin DISK | CABINET | FILE</strong></dt>

			<dd>Start a block of one or more lines to write to the specified area of the INF file.

				<p>The lines in the block will be copied unmodified to the specified section of the INF file, so no MakeCAB variable substitution will be performed. Similarly, MakeCAB will not strip comments.


				</p>
				<p>Use <strong>.InfWrite</strong>, <strong>.InfWriteCabinet</strong>, or <strong>.InfWriteDisk</strong> if you need variable substitution.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.InfBegin disk                ; Text for disk section of INF file
;This is a comment for the disk section.  MakeCAB will not process
;this line, so, for example, %var% will not be substituted.
.InfEnd
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>
				</p>
			</dd>

			<dt><strong>.InfEnd</strong></dt>

			<dd>Terminate an .InfBegin block.

				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.InfEnd            ; Close an .InfBegin block
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>
				</p>
			</dd>

			<dt><strong>.InfWrite  string</strong></dt>

			<dd>Write <em>string</em> to the file area of the INF file.

				<p>Note that lines will have MakeCAB comments removed and variable values substituted. If you want to avoid this processing, use the <strong>.InfBegin File</strong> command. Leading whitespace is normally removed, but you can override this by placing whitespace in quotes (see examples below)


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.InfWrite [A Section Header]  ; Text for file section, this comment
							  ;    will not appear.

.InfWrite ;&lt;disk&gt;,&lt;file&gt;      ; MakeCAB strips off the comments, so this
							  ;    command just writes a blank line!

.InfWrite ";&lt;disk&gt;,&lt;file&gt;"    ; Get that comment in the INF file

.InfWrite "  "%someVar%       ; Get leading space on the INF line
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>
				</p>
			</dd>

			<dt><strong>.InfWriteCabinet  string</strong></dt>

			<dd>Write <em>string</em> to the cabinet area of the INF file.

				<p>Note that lines will have MakeCAB comments removed and variable values substituted. If you want to avoid this processing, use the <strong>.InfBegin Cabinet</strong> command.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.InfWriteCabinet 40%% off your favorite furniture  ; %% collapse down to
					 ; one %, because MakeCAB does variable
					 ; substitution on the string.
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>
				</p>
			</dd>

			<dt><strong>.InfWriteDisk  string</strong></dt>

			<dd>Write <em>string</em> to the disk area of the INF file.

				<p>Note that lines will have MakeCAB comments removed and variable values substituted. If you want to avoid this processing, use the <strong>.InfBegin Disk</strong> command.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.InfWriteDisk The Rain in Spain falls Mainly on the Plain
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>
				</p>
			</dd>

			<dt><strong>.New Disk | Cabinet | Folder</strong></dt>

			<dd>Force a disk, cabinet, or folder break.

				<p>This is used to complete the current disk, cabinet, or folder, and start a new one.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.New Disk     ; Start a new disk
.New Cabinet  ; Start a new cabinet
.New Folder   ; Start a new folder
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a>
				</p>
			</dd>

			<dt><strong>.Set</strong> variable<strong>=</strong>value</dt>

			<dd>Set <em>variable </em>to be equal to <em>value</em>.

				<p>To use <em>variable</em>, surround it with percent signs (%) -- %variable%.


				</p>
				<p>Using an undefined variable is an error, and will cause MakeCAB to stop before pass 2.


				</p>
				<p><em>value </em>may include references to other variables.


				</p>
				<p><em>value </em>may be empty, in which case <em>variable </em>is set to the empty string.


				</p>
				<p>Leading and trailing blanks in <em>value </em>are discarded.


				</p>
				<p>Blanks may be enclose in quote (") or apostrophe (') marks.


				</p>
				<p>Explicit percent signs (%), quotes ("), or apostrophes (') must be specified twice.
				</p>
			</dd>
		</dl>

		<blockquote class="dtBlock">
			<strong>NOTE:</strong> If <strong>.Option Explicit </strong>is specified, then you must first use <strong>.Define </strong>to define any user-defined variables before you can use <strong>.Set </strong>to modify them. For standard MakeCAB variables, <strong>.Define </strong>is not permitted, and only <strong>.Set </strong>may be used on.</blockquote>

		<p class="label"><strong>Examples:</strong></p>

		<pre class="code">.Set lang=ENGLISH                ; Set language
.Set country=USA                 ; Set country
.Set SourceDir=%lang%\%country%  ; SourceDir = [ENGLISH\USA]
.Set join=%lang%%country%        ; join = [ENGLISHUSA]
.Set success=100%%               ; success = [100%]
.Set SourceDir=                  ; SourceDir = []
.Set contraction="don't"         ; contraction = [don't]
.Set contraction=don''t          ; contraction = [don't]
.Set someSpaces=  hi there       ; someSpaces = [hi there]
.Set someMore="  blue dog  "     ; someMore = [  blue dog  ]
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#com">Command Summary</a></p>

		<h4 class="dtH1">
			<a id="var_details"></a>Variable Details</h4>

		<p>The standard MakeCAB variables are listed below. These variables are predefined, and each of them have default value, which is used if you do not set the variable from the command line (/D var=value) or prior to the time you explicitly set the variable with a <strong>.Define</strong> or <strong>.Set</strong> command in a directive file.</p>

		<p>You can create your own variables as well, using the <strong>.Define </strong>command if you specify <strong>.Option Explicit</strong>, and the <strong>.Set </strong>command otherwise.</p>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a>

		</p>
		<dl>
			<dt><strong>Cabinet=On | Off</strong></dt>

			<dd>Turns <em>cabinet mode </em>on or off.

				<p>Default: .Set Cabinet=On ; Cabinet mode is ON<br>



				</p>
				<p>When cabinet mode is <strong>On</strong>, the following applies:


				</p>
				<ol>
					<li>Files are stored in a cabinet, whose name is taken from the CabinetNameTemplate variable</li>

					<li>If the compressed size of a file would cause the current Cabinet to exceed the current MaxCabinetSize variable, then as much of the compressed file as possible is stored in the current Cabinet, that Cabinet is closed, and a new Cabinet is created. Note that it is possible for a large file to span multiple Cabinets!</li>

					<li>If the compressed size of a file (or set of files, if the files are small) would cause the current Folder to exceed the current FolderSizeThreshold variable, these files are the last ones added to the current Folder, a new Folder is started for any subsequent files. (See note below.) Note that if the current Folder cannot fit in the current Cabinet, as much as possible of the Folder is stored in the current Cabinet, and the remainder of the Folder is stored in the next Cabinet. This means that it is possible for several files to be continued from one Cabinet file to the next Cabinet file!</li>
				</ol>


				<blockquote class="dtBlock">
					<strong>NOTE:</strong> The motivation here is that a Folder is a decompression boundary, and so is advisory. To access a file in a Folder, you must start decompressing from the beginning of a Folder, potentially decompressing (and discarding) many files until you arrive at the desired file. If we made the current folder larger, then this file just added would take longer to access. In general, the <strong>FolderSizeThreshold</strong> variable should be several times larger than 32K, to be of any utility.</blockquote>


				<p>When cabinet mode is <strong>Off</strong>, the following applies:


				</p>
				<ol>
					<li>The Compress mode must be <strong>Off</strong></li>

					<li>Files are stored in individual files</li>

					<li>If the destination file is not supplied, the default name is controlled by the <em>compression mode</em> (see the <strong>Compress </strong>variable)</li>
				</ol>


				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set Cabinet=OFF   ; Files not in cabinets...
.Set Compress=OFF  ; ...and no compression.
setup.exe          ; Setup program is simply copied to disk.
.Set Cabinet=ON    ; Use a cabinet...
.SET Compress=ON   ; ...and compress remaining files.
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>CabinetFileCountThreshold</strong>=count</dt>

			<dd>Sets a goal for the maximum number of files in a cabinet.

				<p>Default: .Set CabinetFileCountThreshold=0 ; Default is no threshold


				</p>
				<p><em>count</em> is a threshold for the number of files to store in a cabinet. Once this count has been reached, MakeCAB will close the current cabinet as soon as possible. Due to the blocking of files for compression purposes, it is possible that the cabinet will contain more files than specified by this variable.


				</p>
				<p>If <em>count </em>is 0, then there is no limit on the number files per cabinet.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set CabinetFileCountThreshold=100  ; Shoot for 100 files per cabinet
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>CabinetName</strong>n=filename</dt>

			<dd>The cabinet file name for the specified cabinet.

				<p>Default: ; By default none of these variables are defined


				</p>
				<p>If this variable is not defined for a particular disk, then MakeCAB uses the <strong>CabinetNameTemplate</strong> to construct the cabinet name.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set CabinetName1=one.cab
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>CabinetNameTemplate</strong>=template</dt>

			<dd>Sets the cabinet file name template.

				<p>Default: .Set CabinetNameTemplate=*.CAB ; 1.CAB, 2.CAB, ...


				</p>
				<p>This template is used to construct the file name of each cabinet. The "*" in this template is replaced by the cabinet number (1, 2, etc.). This variable is used only if no variable <strong>CabinetName<em>n</em></strong><em> </em>exists for cabinet <em>n</em>.
				</p>
			</dd>
		</dl>

		<blockquote class="dtBlock">
			<strong>NOTE:</strong> <strong>Be sure that the expanded cabinet name does not exceed the limits for your file system!  </strong>For example, if you used "CABINET*.CAB", and MakeCAB had to create 10 or more cabinets, then you would have cabinet names like CABINET10.CAB, which is 9.3, which is an invalid name in the FAT file system. Unfortunately, MakeCAB would not detect this until it had already created 9 cabinets!</blockquote>

		<p class="label"><strong>Examples:</strong></p>

		<pre class="code">.Set CabinetNameTemplate=EXCEL*.DIA  ; EXCEL1.DIA, EXCEL2.DIA, etc.
.Set CabinetNameTemplate=*.          ; 1, 2, 3, etc.
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>

		</p>
		<dl>
			<dt><strong>ChecksumWidth=1</strong> | <strong>2</strong> | ... | <strong>8</strong></dt>

			<dd>Sets the maximum number of low-order hex digits displayed by <strong>InfFileLineFormat</strong> <strong>csum</strong> parameter.

				<p>Default: .Set ChecksumWidth=8 ; Default is all 8 hex digits (csum is a 32-bit value)


				</p>
				<p>The presence of the <strong>csum </strong>parameter in the <strong>InfFileLineFormat </strong>variable causes MakeCAB to compute a 32-bit CRC for each file and write that checksum to the INF file. While leading zeros are not written out, the presence of these checksums can significantly increase the size of the INF file. You can use <strong>ChecksumWidth </strong>to restrict the size of the checksum written to the INF file. If a value less than 8 is specified, then MakeCAB will mask off the high-order bits of the 32-bit checksum to produce a value for the INF file that is at most the number of hex digits specified.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set ChecksumWidth=4  ; Only display the low order 4 hex digits
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>ClusterSize</strong>=bytesPerCluster</dt>

			<dd>The cluster size of the distribution media.

				<p>Default: .Set ClusterSize=512 ; 1.44M and 1.2M floppies have 512-byte clusters


				</p>
				<p>This is used by MakeCAB to round up the sizes of files and cabinets to a cluster boundary, so it can determine when to switch to the next disk.


				</p>
				<p>You can use a standard disk size from the following list, and MakeCAB will supply the known cluster size for that disk size:


				</p>
				<ul>
					<li><strong>1.44M</strong></li>

					<li><strong>1.25M</strong> (Japanese NEC 3.5" drive capacity)</li>

					<li><strong>1.2M</strong></li>

					<li><strong>720K</strong></li>

					<li><strong>360K</strong></li>

					<li><strong>CDROM</strong></li>
				</ul>


				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set ClusterSize=1.44M  ; Use known 1.44M floppy info
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>Compress=ON</strong> | <strong>OFF</strong></dt>

			<dd>Turn file compression on or off.

				<p>Default: .Set Compress=On ; Compression is on


				</p>
				<p>While compression is usually on, you generally turn if off for the first few files on disk 1 (SETUP.EXE, for example). If the <strong>Cabinet</strong> setting is <strong>Off</strong> then compression must also be <strong>Off</strong>, it is invalid to create single file Cabinets when processing multiple files.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set Cabinet=OFF   ; Files not in cabinets...
.Set Compress=OFF  ; ...and no compression.
setup.exe          ; Setup program is simply copied to disk.
.Set Cabinet=ON    ; Use a cabinet...
.SET Compress=ON   ; ...and compress remaining files.
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong><a id="compfileext"></a>CompressedFileExtensionChar</strong>=char</dt>

			<dd>Last character in file name used when compressing an individual file.

				<p>Default: .Set CompressedFileExtensionChar=_ ; Default is an underscore ("_")


				</p>
				<p>When compressing an individual file through the command line, the file name is constructed by taking the source file name and replacing the last character of the file extension with the setting of this variable. You can use /D CompressedFileExtensionChar=c on the command line to change the appended character. If it's not supplied, then the default value will be used.


				</p>
				<p>This variable is ignored if used in a directive file.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">MAKECAB.EXE /D CompressedFileExtensionChar=$  SAMPLE.EXE ; SAMPLE.EXE =&gt; SAMPLE.EX$
														 ; SAMPLE.EX  =&gt; SAMPLE.EX$
														 ; SAMPLE.E   =&gt; SAMPLE.E$
														 ; SAMPLE.    =&gt; SAMPLE.$
														 ; SAMPLE     =&gt; SAMPLE.$
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>CompressionMemory</strong>=<strong>15</strong> | <strong>16</strong> | ... | <strong>21</strong></dt>

			<dd>Controls the size of the LZX sliding window.

				<p>Default: .Set CompressionMemory=18 ; Default window size 2<span class="sup">18</span> bytes (256KB).


				</p>
				<p>LZX can use a variety of window sizes from 2<span class="sup">15</span> bytes (32KB) to 2<span class="sup">21</span> bytes (2MB). Larger values will generally produce better compression ratios, but will require more time and memory during both compression and decompression.

				</p>
				<p>This variable is ignored if the <strong>CompressionMemory</strong> is LZX.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set CompressionMemory=21  ; 2MB LZX Window Size
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>CompressionType=MSZIP | LZX</strong></dt>

			<dd>Select compression engine.

				<p>Default: .Set CompressionType=MSZIP ; Default is MSZIP compressor


				</p>
				<p>MSZIP is the default compression type supported by Microsoft. This version of MakeCAB.EXE also supports the LZX compression method, which can achieve higher compressions ratios.


				</p>
				<p>Using MSZIP compression and FolderSizeThreshold=1 will generate a cabinet file approximately the same size as a PKZIP-compatible compression engine. LZX compression requires more time, but LZX decompression is typically faster.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set CompressionType=MSZIP  ; MSZIP compressor
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>DestinationDir</strong>=path</dt>

			<dd>Path prefix to store in cabinet file for each file in the cabinet.

				<p>Default: .Set DestinationDir= ; Default is no path prefix


				</p>
				<p><em>path </em> is concatenated with a path separator ("\") and the target file name on File Copy Commands to produce the file name that is stored in cabinet file. EXTRACT.EXE will use this file name as the default name when the file is extracted.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set DestinationDir=SYSTEM  ; Following files get SYSTEM prefix
bin\ARIAL.TTF               ; Name in cabinet is SYSTEM\ARIAL.TTF
.Set DestinationDir=        ; No prefix
bin\ARIAL.TTF               ; Name in cabinet is ARIAL.TTF
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>DiskDirectory</strong>n=directory</dt>

			<dd>The output directory name for the specified disk.

				<p>Default: ; By default none of these variables are defined


				</p>
				<p>If this variable is not defined for a particular disk, then MakeCAB uses the <strong>DiskDirectoryTemplate</strong> to construct the disk directory.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set DiskDirectory1=disk.one
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>DiskDirectoryTemplate</strong>=template</dt>

			<dd>Set the output directory name template. One directory is created for each disk of the layout.

				<p>Default: .Set DiskDirectoryTemplate=DISK* ; Default is DISK1, DISK2, etc.


				</p>
				<p>As MakeCAB processes a directive file, it will create one or more disk "images". Rather than using some specific disk format, however, MakeCAB simply creates one subdirectory for each disk and places the files for each disk in the appropriate directory. If a "*" exists in this variable, then it is replaced with the disk number. If no "*" is specified, then all files are placed in the single directory specified by this variable.


				</p>
				<p>This variable is used only if no variable <strong>DiskDirectory<em>n</em></strong><em> </em>exists for disk <em>n</em>.
				</p>
			</dd>
		</dl>

		<blockquote class="dtBlock">
			<strong>NOTE:</strong> </blockquote>

		<p class="label"><strong>Examples:</strong></p>

		<pre class="code">.Set DiskDirectoryTemplate=C:\EXCEL6\DISK*  ; Put files in separate dirs
.Set DiskDirectoryTemplate=C:\EXCEL6        ; Put all files in C:\EXCEL6
.Set DiskDirectoryTemplate=                 ; Put all files in current dir
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>

		</p>
		<dl>
			<dt><strong>DiskLabel</strong>n=label</dt>

			<dd>The user-readable text string for the specified disk.

				<p>Default: ; By default none of these variables are defined


				</p>
				<p>This <em>label</em> is stored in cabinet files that contain files that are split across disk boundaries, to simplify prompting for the appropriate disk to insert into the drive. For example, if EXCEL.EXE started in 1.CAB and finished in 2.CAB, and a user asked to extract EXCEL.EXE from 2.CAB, EXTRACT.EXE can retrieve the printed label for the disk containing 1.CAB (say, Excel Program Disk 1) and tell the user to insert that disk and try again.


				</p>
				<p>If this variable is not defined for a particular disk, then MakeCAB uses the <strong>DiskLabelTemplate</strong> to construct the disk label.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set DiskLabel1="Excel Setup Disk 1"
.Set DiskLabel2="Excel Setup Disk 2"
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>DiskLabelTemplate</strong>=template</dt>

			<dd>Set the printed disk label. Used if individual <strong>DiskLabel</strong>n variables are not defined.

				<p>Default: .Set DiskLabelTemplate="Disk *" ; Default is "Disk 1", "Disk 2", etc.


				</p>
				<p>Sets the default user-readable disk label. If a "*" exists in this variable, then it is replaced with the disk number. This variable is used only if no variable <strong>DiskLabel<em>n</em></strong><em> </em>exists for disk <em>n</em>.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set DiskLabelTemplate="Excel Disk *"</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>DoNotCopyFiles=On</strong> | <strong>Off</strong></dt>

			<dd>Controls whether File Copy Commands actually copy files.

				<p>Default: .Set DoNotCopyFiles=Off ; Files <em>are </em>copied


				</p>
				<p>This option is intended to be used when Cabinet is OFF and Compress is OFF, as a means of generating an INF file very quickly. It has no affect when Cabinet is ON or Compress is ON.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set DoNotCopyFiles=ON      ; Make MakeCAB create the INF file quickly
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>FolderFileCountThreshold</strong>=count</dt>

			<dd>Set the threshold on the number of files to store in a folder.

				<p>Default: .Set FolderFileCountThreshold=0 ; Default to no limit on count of files in a folder


				</p>
				<p>Sets the threshold file count for the current folder. When this threshold is exceeded, then the current folder is closed. If any more files are to be processed, they will go into a new folder.


				</p>
				<p>If <strong>Cabinet </strong>is <strong>OFF</strong>, this variable is ignored.


				</p>
				<p>If <em>count </em>is 0, then there is no limit on the count of files in a folder.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set FolderFileCountThreshold=50  ; No more than 50 files per folder
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>FolderSizeThreshold</strong>=size</dt>

			<dd>Set the threshold size for the current folder.

				<p>Default: .Set FolderSizeThreshold=0 ; Default to the maximum cabinet size


				</p>
				<p>Sets the threshold size for the current folder. When this threshold is exceeded, then the current folder is closed. If any more files are to be processed, they will go into a new folder. MakeCAB attempts to limit folders to the size specified by this variable, but in most cases folders will be a bit larger than this threshold.


				</p>
				<p>If <strong>Cabinet </strong>is <strong>OFF</strong>, this variable is ignored. If <em>size </em>is 0, then the threshold is the same as the maximum cabinet size.


				</p>
				<p>Folders are compression/encryption boundaries. The state of the compressor and cryptosystem are reset at folder boundaries. To access a file in a folder, the folder must be decrypted and decompressed starting from the <strong>front </strong>of the folder and continuing through to the desired file. Thus, smaller folder thresholds are appropriate for a layout where a small number of files needs to be randomly accessed quickly from a cabinet. On the other hand, larger folder thresholds permit the compressor to examine more data, and so generally yield better compression results. For a layout where the files will be accessed sequentially and most of the files will be accessed, a larger folder threshold is best.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set FolderSizeThreshold=1M  ; Aim for 1Mb folders
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>GenerateInf=ON | OFF</strong></dt>

			<dd>Controls Unified vs. Relational INF generation mode.

				<p>Default: .Set GenerateInf=ON ; Default to "unified" INF mode


				</p>
				<p>If <strong>GenerateInf</strong> is <strong>ON </strong>when the first file copy command is encountered, then Unified INF mode is selected. In this mode, file detail lines are written to the INF file as file copy commands are processed, so the order of file lines in the INF is exactly the same as the order of the files in the layout.


				</p>
				<p>If <strong>GenerateInf</strong> is <strong>OFF</strong> when the first file copy command is encountered, then Relational INF mode is selected. In this mode, file copy commands are processed, but INF file generation is delayed until <strong>GenerateInf</strong> is set to <strong>ON</strong>, and File Reference commands are used to select information on files in the layout to be placed in the INF file.


				</p>
				<p><em>Unified mode</em> is easier to use, since each file is specified only once, and is most appropriate for quick usage of MakeCAB.


				</p>
				<p><em>Relational mode</em> is more complicated, since each file must be specified (at least) twice, but it provides very fine control of both the disk layout <strong>and </strong>the format of the INF file. In particular, some INF files want to have sections to list the files associated with a certain feature, there may be many such sections, and some files may be required in more than one section. Unified mode does not provide any method to generate such an INF file, but Relational mode does via the File Reference command.


				</p>
				<p>By separating the disk layout order from the INF file order, MakeCAB permits optimization of the file layout for compression vs. access time. The <em>layout section </em>of the DDF contains file copy commands that control precisely where files are in the layout. The <em>INF section </em>of the DDF contains INF formatting information, including File Reference commands to pull in information about specific files from earlier File Copy commands in the layout section.
				</p>
			</dd>
		</dl>

		<blockquote class="dtBlock">
			<strong>NOTE:</strong> Once <strong>GenerateInf</strong> is set to <strong>ON </strong>and at least one File Copy command has been processed, <strong>GenerateInf</strong> may not be set to <strong>OFF</strong> (i.e., in Relational Mode, all File Copy commands must be processed before any File Reference commands)</blockquote>

		<p class="label"><strong>Examples:</strong></p>

		<pre class="code">;** Layout section - File Copy commands
.Set GenerateInf=OFF
foo.exe
bar.exe other.exe
foo.exe foo1.exe
....

;** INF section -- File Reference commands
.Set GenerateInf=ON
.WriteInf "[a section]"
foo.exe
other.exe
foo1.exe /rename=sys\foo.exe   ; pass custom parameter
....
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>

		</p>
		<dl>
			<dt><strong>Inf</strong><em>Xxx</em>=string</dt>

			<dd>Sets the default value for an INF parameter.

				<p>Default: [Not applicable]


				</p>
				<p>Variables of this form (other than the standard ones in this list) can be used for two purposes:


				</p>
				<ol>
					<li>To override the usual value of a standard INF parameter (like <strong>date</strong>, <strong>time</strong>, <strong>attr</strong>, etc.) for all the files (or a set of files) in the layout.</li>

					<li>To define a custom INF parameter, and specify its default value.</li>
				</ol>
			</dd>
		</dl>

		<blockquote class="dtBlock">
			<strong>NOTE:</strong> When in Relation INF mode, only the <strong>last value</strong> for a particular <strong>Inf</strong>Xxx variable will be carried over from the layout section to the INF section of the DDF. In the following example:</blockquote>

		<pre class="code"><code class="ce">;** Layout section - File Copy commands
.Set GenerateInf=OFF    ; Select Relational INF
.Set InfCustom=apple
file.1
.Set InfCustom=pear
file.2
;** INF section - File Reference commands
.Set GenerateInf=ON
file.1                  ; *custom* value is "pear", not "apple"!
file.2</code></pre>

		<p class="label"><strong>Examples:</strong></p>

		<pre class="code">.Set InfDate=05/02/94   ; Date stamp all files
.Set InfTime=06:00:00a  ; Time stamp all files
.Set InfAttr=           ; Turn off all attributes (esp. read-only)
.Set InfCustom=yes      ; Define custom INF parameter
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>

		</p>
		<dl>
			<dt><strong>InfCabinetHeader</strong>[<em>n</em>]=string</dt>

			<dd>Sets the header text for the cabinet section of the INF file.

				<p>Default: .Set InfCabinetHeader="[cabinet list]"


				</p>
				<p>This string is written to the INF prior to any cabinet detail lines. MakeCAB will also use any variables of the form <strong>InfCabinetHeader</strong><em>n</em> where <em>n </em>is an integer with no leading zeros (0). These additional lines will be printed out in increasing order after the <strong>InfCabinetHeader</strong> line. Any <strong>.InfBegin</strong> <strong>Cabinet</strong>/<strong>.InfEnd</strong> lines will be printed as they are encountered, but in any event after all of these header lines.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set InfCabinetHeader=";Lots o' cabinets"

.Set InfCabinetHeader=                 ; No cabinet header

.Set InfCabinetHeader=";Line 1 of cabinets"
.Set InfCabinetHeader1=";Line 2 of cabinets"
.Set InfCabinetHeader2=";Line 3 of cabinets"
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>InfCabinetLineFormat</strong>[<em>n</em>]=format string</dt>

			<dd>Sets the detail line format for the cabinet section of the INF file.

				<p>Default: .Set InfCabinetLineFormat=*cab#*,*disk#*,*cabfile*


				</p>
				<p>This format is used to generate a line in the "cabinet" section of the INF. If a numeric suffix <em>n </em>is specified in the variable name, then the specified format is used for cabinet number <em>n</em>. If no such cabinet number-specific format is defined, then the value of the <strong>InfCabinetLineFormat</strong> variable is used.


				</p>
				<p>See <a href="#semantics">InfDisk/Cabinet/FileLineFormat Syntax and Semantics</a> for details on the format string.


				</p>
				<p>See <a href="#inf">INF Parameters</a> for a list of the allowed parameter names.


				</p>
				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>InfCommentString</strong>=string</dt>

			<dd>Sets the line comment string for the INF file.

				<p>Default: .Set InfCommentString=";"


				</p>
				<p>This is the string MakeCAB will use to prefix comment lines that it generates in the INF (the autogenerated MakeCAB version/date/time lines, for example).


				</p>
				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>InfDateFormat=</strong>YYYY-MM-DD | MM/DD/YY</dt>

			<dd>Sets the date format used for dates written to the INF file.

				<p>Default: .Set InfDateFormat=MM/DD/YY ; Default to normal US convention


				</p>
				<p>This format is used to format the <strong>date </strong>parameter for the <strong>InfFileLineFormat </strong>used to write file detail lines to the INF file.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set InfDateFormat=YYYY-MM-DD       ; Use the preferred ACME format
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>InfDiskHeader</strong>[<em>n</em>]=string</dt>

			<dd>Sets the header text for the disk section of the INF file.

				<p>Default: .Set InfDiskHeader="[disk list]"


				</p>
				<p>This string is written to the INF prior to any disk detail lines. MakeCAB will also use any variables of the form <strong>InfDiskHeader</strong><em>n</em> where <em>n </em>is an integer with no leading zeros (0). These additional lines will be printed out in increasing order after the <strong>InfDiskHeader</strong> line. Any <strong>.InfBegin</strong> <strong>Disk</strong>/<strong>.InfEnd</strong> lines will be printed as they are encountered, but in any event after all of these header lines.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set InfDiskHeader=";Lots o' Disks"

.Set InfDiskHeader=      ; No Disk header

.Set InfDiskHeader=";Line 1 of Disks"
.Set InfDiskHeader1=";Line 2 of Disks"
.Set InfDiskHeader2=";Line 3 of Disks"
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>InfDiskLineFormat</strong>[<em>n</em>]=format string</dt>

			<dd>Sets the detail line format for the disk section of the INF file.

				<p>Default: .Set InfDiskLineFormat=*disk#*,*label*


				</p>
				<p>This format is used to generate a line in the "disks" section of the INF. If a numeric suffix <em>n </em>is specified in the variable name, then the specified format is used for disk number <em>n</em>. If no such disk number-specific format is defined, then the value of the <strong>InfDiskLineFormat</strong> variable is used.


				</p>
				<p>See <a href="#semantics">InfDisk/Cabinet/FileLineFormat Syntax and Semantics</a> for details on the format string.


				</p>
				<p>See <a href="#inf">INF Parameters</a> for a list of the allowed parameter names.


				</p>
				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>InfFileHeader</strong>[<em>n</em>]=string</dt>

			<dd>Sets the header text for the file section of the INF file.

				<p>Default: .Set InfFileHeader="[file list]"


				</p>
				<p>This string is written to the INF prior to any file detail lines. MakeCAB will also use any variables of the form <strong>InfFileHeader</strong><em>n</em> where <em>n </em>is an integer with no leading zeros (0). These additional lines will be printed out in increasing order after the <strong>InfFileHeader</strong> line. Any <strong>.InfBegin</strong> <strong>File</strong>/<strong>.InfEnd</strong> lines will be printed as they are encountered, but in any event after all of these header lines.


				</p>
				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>InfFileLineFormat</strong>[<em>n</em>]=format string</dt>

			<dd>Sets the detail line format for the file section of the INF file.

				<p>Default: .Set InfFileLineFormat=*disk#*,*cab#*,*file*,*size*


				</p>
				<p>This format is used to generate a line in the "file" section of the INF. If a numeric suffix <em>n </em>is specified in the variable name, then the specified format is used for file number <em>n </em>(file numbers start at 1, and are based on the File Copy Commands, not the File Reference Commands). If no such file number-specific format is defined, then the value of the <strong>InfFileLineFormat</strong> variable is used.


				</p>
				<p>See <a href="#semantics">InfDisk/Cabinet/FileLineFormat Syntax and Semantics</a> for details on the format string.


				</p>
				<p>See <a href="#inf">INF Parameters</a> for a list of the allowed parameter names.


				</p>
				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>InfFileName</strong>=filename</dt>

			<dd>Sets the name of the INF output file.

				<p>Default: .Set InfFileName=SETUP.INF ; Default file name is SETUP.INF


				</p>
				<p>Defines the file name for the INF file. This file has disk, cabinet, and file information that is intended for use by a setup program during the setup process.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set InfFileName=EXCEL.INF
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>InfFooter</strong>[<em>n</em>]=string</dt>

			<dd>Sets the footer text for beginning of the INF file.

				<p>Default: // Run MakeCAB and use the .Dump command to see the default footer


				</p>
				<p>These strings are written to the INF file after all other information. To disable this footer text, set InfFooter to the empty string (.Set InfFooter=). MakeCAB will also use any variables of the form <strong>InfFooter</strong><em>n</em> where <em>n </em>is an integer with no leading zeros (0). These additional lines will be printed out in increasing order after the <strong>InfFooter</strong> line, starting with <strong>InfFooter1</strong>.


				</p>
				<p>The following special strings may be specified in InfFooter[n] values (note that the two percent signs are required, so that MakeCAB does not interpret these as variable references):

				</p>
				<div class="tablediv">
					<table class="dtTABLE" responsive="true" summary="table">

						<tbody>
							<tr responsive="true">
								<th scope="col">String</th>
								<th scope="col">Description</th>
							</tr>

							<tr>
								<td data-th="String">%%1</td>
								<td data-th="Description">The comment string -- each InfFooter[n] line should probably start with %%1.</td>
							</tr>

							<tr>
								<td data-th="String">%%2</td>
								<td data-th="Description">The date and time MakeCAB was run to produce the INF file.</td>
							</tr>

							<tr>
								<td data-th="String">%%3</td>
								<td data-th="Description">The version of MakeCAB use to produce the INF file.</td>
							</tr>
						</tbody>
					</table>
				</div>



				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set InfFooter=             ; Disable INF footer text
.Set InfFooter="%%1 %2 %3"  ; Short footer
.Set InfFooter="%%1*****"   ; Long footer
.Set InfFooter1="%%1* %2"   ; Long footer continued
.Set InfFooter2="%%1* %3"   ; Long footer continued
.Set InfFooter3="%%1*****"  ; Long footer continued
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>InfHeader</strong>[<em>n</em>]=string</dt>

			<dd>Sets the header text for beginning of the INF file.

				<p>Default: // Run MakeCAB and use the .Dump command to see the default header.


				</p>
				<p>These strings are written to the INF file prior to any other information. To disable this header text, set InfHeader to the empty string (.Set InfHeader=). MakeCAB will also use any variables of the form <strong>InfHeader</strong><em>n</em> where <em>n </em>is an integer with no leading zeros (0). These additional lines will be printed out in increasing order after the <strong>InfHeader</strong> line, starting with <strong>InfHeader1</strong>.


				</p>
				<p>The following special strings may be specified in InfHeader[n] values (note that the two percent signs are required, so that MakeCAB does not interpret these as variable references):

				</p>
				<div class="tablediv">
					<table class="dtTABLE" responsive="true" summary="table">

						<tbody>
							<tr responsive="true">
								<th scope="col">String</th>
								<th scope="col">Description</th>
							</tr>

							<tr>
								<td data-th="String">%%1</td>
								<td data-th="Description">The comment string -- each InfHeader[n] line should probably start with %%1.</td>
							</tr>

							<tr>
								<td data-th="String">%%2</td>
								<td data-th="Description">The date and time MakeCAB was run to produce the INF file.</td>
							</tr>

							<tr>
								<td data-th="String">%%3</td>
								<td data-th="Description">The version of MakeCAB use to produce the INF file.</td>
							</tr>
						</tbody>
					</table>
				</div>



				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set InfHeader=             ; Disable INF header text
.Set InfHeader="%%1 %2 %3"  ; Short header
.Set InfHeader="%%1*****"   ; Long header
.Set InfHeader1="%%1* %2"   ; Long header continued
.Set InfHeader2="%%1* %3"   ; Long header continued
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>.Set InfHeader3="%%1*****"    ; Long header continuedInfSectionOrder=[D | C | F]*</strong></dt>

			<dd>Set the generation and relative order of the Disk, Cabinet, and File sections in the INF file.

				<p>Default: .Set InfSectionOrder=DCF ; Disk, then Cabinet, and then File


				</p>
				<p>This variable controls what sections of the INF file are generated, and the order in which they appear. Each of the letters "C" (cabinet), "D" (disk), and "F" (file) may be used at most once. Any or all of these letters may be omitted, and the corresponding section of the INF file will not be generated.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set InfSectionOrder=DF  ; Disks, then files, omit the cabinet section
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>MaxCabinetSize</strong>=size</dt>

			<dd>Set the maximum size for the current cabinet.

				<p>Default: .Set MaxCabinetSize=0 ; No limit, except MaxDiskSize


				</p>
				<p><em>size</em> is the maximum size for the current cabinet. If <strong>Cabinet </strong>is <strong>ON</strong> when this maximum is exceeded, then the current folder being processed will be split between the current cabinet and the next cabinet. If <strong>Cabinet </strong>is <strong>OFF</strong>, then this variable is ignored.


				</p>
				<p>Note that <strong>MaxDiskSize </strong>(or <strong>MaxDiskSize</strong><em>n</em>, if specified) takes precedence over this variable. MakeCAB never splits a cabinet file across a disk boundary, so a cabinet file will be no larger than the amount of free space available on the disk at the time the cabinet is created, even if this size is less than <strong>MaxCabinetSize</strong>.


				</p>
				<p>If <em>size </em>is 0, then the cabinet size is limited only by the disk size (<strong>MaxDiskSize or MaxDiskSize</strong><em>n</em>).


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set MaxCabinetSize=0  ; Use disk size as limit</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>MaxDiskFileCount</strong>=count</dt>

			<dd>Sets the maximum number of files that can be stored on a disk.

				<p>Default: .Set MaxDiskFileCount=0 ; Default is no limit


				</p>
				<p><em>count</em> is the maximum number of files to store on a disk. Once this count has been reached, MakeCAB will close the current disk, even if space remains on the disk. This variable is most useful when cabinet files are not being used (say, to simulate the old style setup where each file is individually compressed), and MakeCAB needs to understand the limit of the number of files that can be stored in the root directory of a floppy.


				</p>
				<p>If <em>count </em>is 0, then there is no limit on the number files per disk.


				</p>
				<p>You can use a standard disk size from the following list, and MakeCAB will supply the known FAT root directory limits for that disk size:


				</p>
				<ul>
					<li><strong>1.44M</strong></li>

					<li><strong>1.25M</strong> (Japanese NEC 3.5" drive capacity)</li>

					<li><strong>1.2M</strong></li>

					<li><strong>720K</strong></li>

					<li><strong>360K</strong></li>

					<li><strong>CDROM</strong></li>
				</ul>


				<p>The file count does <strong>not </strong>include any files inside cabinets. Each cabinet counts as a single file for purposes of this count.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set DiskFileCountMax=256    ; Limit of 256 files per disk
.Set DiskFileCountMax=1.44M  ; Use limit for 1.44M FAT floppy disk</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>MaxDiskSize</strong>[<em>n</em>]=size</dt>

			<dd>Set the maximum default size for a disk.

				<p>Default: .Set MaxDiskSize=1.44M ; Default is 1.44M floppy


				</p>
				<p><em>size</em> is the maximum default size for a disk. This variable is used only for disks for which a variable <strong>MaxDiskSize</strong><em>n</em> is not defined.


				</p>
				<p>If <strong>Cabinet </strong>is <strong>OFF</strong>, and the next file to be laid out cannot fit on the current disk, then MakeCAB will move to the next disk. If <strong>Cabinet </strong>is <strong>ON</strong>, then the current cabinet will use as much space on the current disk as possible.


				</p>
				<p>If <em>size </em>is 0, then the disk size is unlimited.


				</p>
				<p>You can use a standard disk size from the following list, and MakeCAB will use the correct disk size, down to the byte:


				</p>
				<ul>
					<li><strong>1.44M</strong></li>

					<li><strong>1.25M</strong> (Japanese NEC 3.5" drive capacity)</li>

					<li><strong>1.2M</strong></li>

					<li><strong>720K</strong></li>

					<li><strong>360K</strong></li>

					<li><strong>CDROM</strong></li>
				</ul>


				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set MaxDiskSize=0      ; No limit
.Set MaxDiskSize=CDROM  ; All files are being placed on a CD-ROM

.Set MaxDiskSize1=720K  ; First disk is 720K
.Set MaxDiskSize=1.44M  ; ... rest are 1.44M
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>MaxErrors</strong>=count</dt>

			<dd>Set the maximum number of errors allowed before pass 1 terminates.

				<p>Default: .Set MaxErrors=20 ; Default is 20 errors


				</p>
				<p><em>count </em>is the maximum number of errors to permit before terminating pass 1.


				</p>
				<p>If <em>count </em>is 0, then an unlimited number of errors is allowed.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set MaxErrors=0  ; No limit
.Set MaxErrors=5  ; Limit to just a few
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>ReservePerCabinetSize</strong>=size</dt>

			<dd>Sets a fixed size to reserve in a cabinet for the FCRESERVE structure.

				<p>Default: .Set ReservePerCabinetSize=0 ; Default is to reserve no space


				</p>
				<p><em>size </em>is the amount of space to reserve in a cabinet for the FCRESERVE structure. The total size of the FCRESERVE structure is the value of this variable plus the number of folders in the cabinet times the value of the <strong>ReservePerFolderSize </strong>variable.


				</p>
				<p><em>size </em>must be a multiple of 4 (to ensure memory alignment on certain systems).


				</p>
				<p>A common use for this variable is to reserve space to store per-folder cryptosystem information, in the case where the cabinet is encrypted. For example, some sort of checksum value might be stored here to permit validation that the key being used to decrypt the cabinet is actually the one that was used to encrypt the cabinet.


				</p>
				<p>MakeCAB fills this reserved section with zeros.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set ReservePerCabinetSize=8  ; For use as a cryptosystem key checksum
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>ReservePerDataBlockSize</strong>=size</dt>

			<dd>Sets the amount of space to reserve in each Data Block header.

				<p>Default: .Set ReservePerDataBlockSize=0 ; Default is to reserve no space


				</p>
				<p><em>size </em>is the amount of space to reserve in each Data Block header. This space is located after the standard Data Block header and before the data for the data block.


				</p>
				<p><em>size </em>must be a multiple of 4 (to ensure memory alignment on certain systems).


				</p>
				<p>One possible use for this variable is to reserve space to store a per-data block cryptosystem information, in the case where the cabinet is encrypted. (See note below.)
				</p>
			</dd>
		</dl>

		<blockquote class="dtBlock">
			<strong>NOTE:</strong> [6/6/94] Ali Baba is not using this value, so even though it has been implemented and tested, there are no known customers.</blockquote>

		<p>MakeCAB fills this reserved section with zeros.</p>

		<p class="label"><strong>Examples:</strong></p>

		<pre class="code">.Set ReservePerCabinetSize=4  ; Reserve 4 bytes per data block
</pre>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>

		</p>
		<dl>
			<dt><strong>ReservePerFolderSize</strong>=size</dt>

			<dd>Sets the amount of additional space to reserve in the FCRESERVE structure for each folder in the cabinet.

				<p>Default: .Set ReservePerFolderSize=0 ; Default is to reserve no space


				</p>
				<p><em>size </em>is the amount of space to reserve in the FCRESERVE structure for each folder in the cabinet. The total size of the FCRESERVE structure is the value of this variable times the value of the number of folders in the cabinet, plus the value of the <strong>ReservePerCabinetSize </strong>variable.


				</p>
				<p><em>size </em>must be a multiple of 4 (to ensure memory alignment on certain systems).


				</p>
				<p>A common use for this variable is to reserve space to store a per-folder cryptosystem key, in the case where the cabinet is encrypted.


				</p>
				<p>MakeCAB fills this reserved section with zeros.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set ReservePerCabinetSize=8  ; Size of an RC4 cryptosystem key
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>RptFileName</strong>=filename</dt>

			<dd>Sets the name of the RPT output file.

				<p>Default: .Set RptFileName=SETUP.RPT ; Default file name is SETUP.RPT


				</p>
				<p>Defines the file name for the RPT file. This file has summary information on the MakeCAB run.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set RptFileName=EXCEL.RPT
</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>SourceDir</strong>=path</dt>

			<dd>The default path used to locate source files specified in File Copy Commands.

				<p>Default: .Set SourceDir= ; Default is to look in the current directory


				</p>
				<p><em>path </em> is concatenated with a path separator ("\") and the source file name on the File Copy Command to produce the file name used to find the source file.


				</p>
				<p>If <em>path </em>is empty, then the source file name specified on the File Copy Command is not modified.


				</p>
				<p class="label"><strong>Examples:</strong>


				</p>
				<pre class="code">.Set SourceDir=C:\PROJECT  ; Find all source files in c:\project</pre>


				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a> &gt; <a href="#var_details">Variable Details</a>
				</p>
			</dd>

			<dt><strong>UniqueFiles=ON</strong> | <strong>OFF</strong></dt>

			<dd>Controls whether destination file names in a layout must be unique.

				<p>Default: .Set UniqueFiles="ON" ; File names must be unique


				</p>
				<p>If <strong>UniqueFiles</strong> is <strong>ON</strong>, MakeCAB checks that all destination file names (names stored on disks or in cabinets) are unique, and generates an error (during pass 1) if they are not. <strong>ON</strong> is the default, since using the same filename twice usually means that the same file was accidentally included twice, and this would be a waste of disk space.


				</p>
				<p>If <strong>UniqueFiles</strong> is <strong>OFF</strong>, MakeCAB permits duplicate destination file names.


				</p>
				<p>The <strong>/UNIQUE</strong> parameter may be specified on individual File Copy commands to override the value of <strong>UniqueFiles</strong>.


				</p>
				<p>If the <strong>GenerateInf</strong> variable is used to select Relational INF generation, then <strong>UniqueFiles</strong> must always be <strong>ON</strong>, since MakeCAB uses the destination filename as the unique key to link File Reference commands back to File Copy commands.


				</p>
				<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> &gt; <a href="#makecab_exe">MAKECAB.EXE</a> &gt; <a href="#dir_file_syntax">MAKECAB.EXE Directive File Syntax</a>
				</p>
			</dd>
		</dl>

		<h3 class="dtH1">
			<a id="extract_exe"></a>EXTRACT.EXE</h3>

		<p>Extract supports command-line extraction of files from cabinet files.</p>

		<pre class="code"><strong>extract </strong>[<strong>/y</strong>] [<strong>/A</strong>] [<strong>/D</strong> |<strong> /E</strong>] [<strong>/L </strong><em>location</em>] <em>cabinet_file</em> [<em>file_spec</em> ...]
<strong>extract</strong> [<strong>/y</strong>] <em>compressed_file</em> [<em>destination_file</em>]
</pre>

		<p class="label"><strong>Switches:</strong></p>
		<div class="tablediv">
			<table class="dtTABLE" summary="table">

				<tbody>
					<tr>
						<td><strong>/A</strong></td>
						<td>Process <strong>all </strong>files in a cabinet set, starting with the <em><code>cabinet_file.</code></em></td>
					</tr>

					<tr>
						<td><strong>/D</strong></td>
						<td>Only produce a directory listing (do not extract).</td>
					</tr>

					<tr>
						<td><strong>/E</strong></td>
						<td>Force extraction.</td>
					</tr>

					<tr>
						<td><strong>/L</strong></td>
						<td>Use the directory specified by <em>location</em>, instead of the current directory, as the default location to place extracted files.</td>
					</tr>

					<tr>
						<td><strong>/Y</strong></td>
						<td>Overwrite destination without prompting. The default is to prompt if the destination file already exists, and allow the customer to: a) overwrite the file, b) skip the file, c) overwrite this file and all subsequent files that may already exist, or d) exit.</td>
					</tr>
				</tbody>
			</table>
		</div>

		<h4 class="dtH1">Parameters:</h4>

		<dl>
			<dt><em>compressed_file</em></dt>

			<dd>This is a cabinet file that contains a single file (example, FOO.EX_ containing FOO.EXE). If <em>destination_file </em>is not specified, then the file is extracted and given its original name in the current directory.</dd>

			<dt><em>destination_file</em></dt>

			<dd>This can be either a relative path (".:, "..", "c:foo", etc.) or a fully qualified path, and may specify either a file (or files, if wild cards are included) or a directory. If a directory is specified, then the file name stored in the cabinet is used. Otherwise, <em>destination_file</em> is used as the complete file name for the extracted file.</dd>

			<dt><em>cabinet_file</em></dt>

			<dd>This is a cabinet file that contains two or more files. If no <em>file_spec </em>parameter is specified, then a list of the files in the cabinet is displayed. If one or more <em>file_spec </em>parameters are specified, then these are used to select which files are to be extracted from the cabinet (or cabinets). Wild cards are allowed to specify multiple cabinets.</dd>

			<dt><em>location</em></dt>

			<dd>Specifies the directory where extracted files should be placed.</dd>

			<dt><em>file_spec</em></dt>

			<dd>Specifies files to be extracted from the cabinet(s). May contain ? and * wild cards. Multiple file_specs may be supplied.</dd>
		</dl>

		<p class="label"><strong>Examples:</strong></p>
		<div class="tablediv">
			<table class="dtTABLE" responsive="true" summary="table">

				<tbody>
					<tr responsive="true">
						<th scope="col">Command</th>
						<th scope="col">Behavior</th>
					</tr>

					<tr>
						<td data-th="Command">EXTRACT foo.ex_</td>
						<td data-th="Behavior">Assuming foo.ex_ contained just the single file foo.exe, then foo.exe would be extracted and placed in the current directory.</td>
					</tr>

					<tr>
						<td data-th="Command">EXTRACT foo.ex_ bar.exe</td>
						<td data-th="Behavior">Assuming foo.ex_ contained just the single file foo.exe, then foo.exe would be extracted and placed in the current directory in the file bar.exe.</td>
					</tr>

					<tr>
						<td data-th="Command">EXTRACT cabinet.1</td>
						<td data-th="Behavior">Assuming cabinet.1 contains multiple files, then a list of the files stored in the cabinet would be displayed.</td>
					</tr>

					<tr>
						<td data-th="Command">EXTRACT cabinet.1 *.exe</td>
						<td data-th="Behavior">Extract all *.EXE files from cabinet.1 and place them in the current directory</td>
					</tr>
				</tbody>
			</table>
		</div>

		<p>Back to: <a href="#microsoftmakecabusersguide">MakeCAB User's Guide</a> </p>

		<h2 class="dtH1">
			<a id="top"></a>
			<a id="microsoftmszipdatacompressionformat"></a>Microsoft MSZIP Data Compression Format</h2>

		<p>Copyright © 1997 Microsoft Corporation. All rights reserved.</p>

		<p><strong>Topics in this section</strong></p>

		<p><a href="#microsoftmszipdatacompressionformat">Introduction</a> <br>
			<a href="#imp_details">Implementation Details</a> <br>
			<a href="#def_spec">Where to Find the 'Deflate' Specifications</a> </p>

		<h3 class="dtH1">
			<a id="intro"></a>Introduction</h3>

		<p>This document describes the format of MSZIP compressed data as used in the MSZIP compression mode of Microsoft's cabinet files. The purpose of this document is to allow anyone to encode or decode MSZIP compressed data.</p>

		<p>Back to: <a href="#microsoftmszipdatacompressionformat">MSZIP Data Compression Format</a> </p>

		<h3 class="dtH1">
			<a id="imp_details"></a>Implementation Details</h3>

		<p>MSZIP compression has only minor variations from Phil Katz's 'deflate' method. Rather than re-document this method, this document will explain these variations and refer the reader to publicly available 'deflate' documents. Some 'deflate' implementations may contain extensions to the original specifications, but MSZIP uses only the three basic modes of deflate: stored, fixed Huffman tree, and dynamic Huffman tree.</p>

		<p>Each MSZIP data block is the result of a complete 'deflate' compression operation. Each block is flushed out of the compressor before the next block begins, so the last sub-block in each block will be marked as the 'end' of the stream. Any decoding trees are discarded after each block, with only the history buffer surviving from one block to the next. Each data block represents 32k uncompressed, except that the last block in a folder may be smaller. A two-byte MSZIP signature precedes the compressed encoding in each block, consisting of the bytes 0x43, 0x4B.</p>

		<p>The maximum compressed size of each MSZIP block is 32k + 12 bytes. This allows for the data to be passed as two separate "stored" sub-blocks, which each have a 5-byte overhead, plus the 2-byte signature. The Microsoft MSZIP compressor will emit "stored" sub-blocks with a length of exactly 32k, while some implementations do not exceed 32k-1.</p>

		<p>Whenever a cabinet folder boundary is reached, the compression history is discarded, so that decoding any folder does not require any prior data.</p>

		<p>Back to: <a href="#microsoftmszipdatacompressionformat">MSZIP Data Compression Format</a> </p>

		<h3 class="dtH1">
			<a id="def_spec"></a>Where to Find the "Deflate" Specifications</h3>

		<p>The "deflate" algorithm was original documented by Phil Katz in APPNOTE.TXT, which accompanied the PKZip software. Its most recent description can be found in RFC 1951. (Try ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html for pointers to obtain this RFC.)</p>

		<p>Back to: <a href="#microsoftmszipdatacompressionformat">MSZIP Data Compression Format</a> </p>

		<div class="footer">
			<br>

			<p></p>
			<p><a href="https://msdn.microsoft.com/en-us/library/ms369863.aspx">© Microsoft Corporation. All rights reserved.</a></p>
		</div>
	</div>

</div>